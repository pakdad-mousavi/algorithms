const k=(u,d)=>{const e=[...u],s=[];let n;do{const t=[];n=!1;for(let c=0;c<e.length-1;c++){const r={pairStart:c,state:e.slice(),swapped:null},o=d?e[c]>e[c+1]:e[c]<e[c+1];o&&([e[c],e[c+1]]=[e[c+1],e[c]],n=!0),r.swapped=o,t.push(r)}t.push({pairStart:null,state:e.slice(),swapped:null}),s.push(t)}while(n);return s},A=(u,d)=>{const e=[],s=[...u];for(let n=0;n<u.length-1;n++){const t=s.slice(n),c=d?Math.min(...t):Math.max(...t),r=t.indexOf(c)+n,o={oldState:s.slice(),selection:c,selectionIdx:r};[s[n],s[r]]=[s[r],s[n]],o.newState=s.slice(),e.push(o)}return e},x=(u,d)=>{const e=[],s=[...u];for(let n=1;n<s.length;n++){const t=s[n],r=s.slice(0,n).findIndex(i=>d?i>t:i<t),o=s.slice();let h=null;r>-1&&(s.splice(r,0,null),s.splice(n+1,1),h=s.slice(),s[r]=t),e.push({pos:r,oldState:o,intermediateState:h,newState:s.slice(),currentNum:t})}return e},y=(u,d)=>{const e=[],s=[...u],n=Math.ceil(Math.log2(s.length)),t=(r,o)=>{const h=[];let i=0,l=0;for(;i<r.length&&l<o.length;)(d?r[i]<=o[l]:r[i]>=o[l])?(h.push(r[i]),i++):(h.push(o[l]),l++);return h.concat(r.slice(i)).concat(o.slice(l))},c=(r,o)=>{if(r.length<=1)return r;const h=n-o+1,i=Math.ceil(r.length/2),l=r.slice(0,i),a=r.slice(i),p=c(l,o+1),g=c(a,o+1);return e.push({splitDepth:o,left:l.slice(),right:a.slice(),mergeDepth:h,mergedLeft:p.slice(),mergedRight:g.slice()}),t(p,g)};return c(s,1),e},M=(u,d)=>{const e=[...u];let s=1;const n=({id:o,group:h})=>{const i=Math.ceil(h.length/2)-1,l=h[i],a=[],p=[];for(let m=0;m<h.length;m++){if(m===i)continue;const f=h[m];f<l?d?a.push(f):p.push(f):d?p.push(f):a.push(f)}const g=[];return a.length&&g.push({id:s++,group:a}),g.push({id:o,group:[l]}),p.length&&g.push({id:s++,group:p}),g},t=o=>o.map(({id:h,group:i})=>({id:h,group:[...i]}));return(o=>{s=1;const h=[],i=s++;let l=n({id:i,group:o});h.push({before:{id:1,group:o},after:t(l),state:t(l)});const a=l.filter(p=>p.group.length>1).map(p=>p.id);for(;a.length;){const p=a.shift(),g=l.findIndex(S=>S.id===p);if(g===-1||l[g].group.length<=1)continue;const m=t(l)[g],f=n(l[g]);l.splice(g,1,...f);for(const S of f)S.id!==p&&S.group.length>1&&a.push(S.id);h.push({before:m,after:f,state:t(l)})}return h})(e)},w=(u,d=!0)=>{const e=Math.min(...u),s=Math.max(...u),n={range:s-e+1,counts:[],reconstructedArrays:[]},t=new Array(s-e+1).fill(0);for(const o of u)t[o-e]++;n.counts=t;const c=[],r=d?[...Array(t.length).keys()]:[...Array(t.length).keys()].reverse();for(const o of r){const h=o+e,i=t[o];if(i===0)continue;for(let a=0;a<i;a++)c.push(h);const l=c.slice();for(;l.length<u.length;)l.push(null);n.reconstructedArrays.push(l)}return n},q=(u,d)=>{const e={k:Math.floor(Math.sqrt(u.length)),unsortedBuckets:null,sortedBuckets:null,sortedNums:null},s=u.length;if(s<=1)return u;let n=Array.from({length:e.k},()=>[]);for(let t=0;t<s;t++){let c=Math.floor(u[t]*e.k);c===e.k&&(c=e.k-1),n[c].push(u[t])}e.unsortedBuckets=n.map(t=>t.slice());for(let t=0;t<e.k;t++)n[t].sort((c,r)=>c-r);return e.sortedBuckets=n.map(t=>t.slice()),e.sortedNums=[].concat(...n),e};export{q as a,k as b,w as c,x as i,y as m,M as q,A as s};
