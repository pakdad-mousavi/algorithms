import{r as E,a as q,w as G,c as Z,b as v,u as D,t as W,d as T,e,f as R,v as S,g as k,h as $,i as J,F as K,j as F,k as d,l,o as p,m as X}from"./index-CkdJ9qdl.js";import{_ as Y,a as h,b as _,c as ee}from"./TrashButton-Ny0rn7_4.js";import{_ as te,a as se}from"./ProcessDetails-CHEq7Z9V.js";import{_ as le}from"./Alert-DANzGrec.js";const ne={class:"mb-10 space-y-4"},ie={class:"flex flex-wrap items-end gap-4"},oe={class:"flex flex-col flex-1 gap-2"},re={class:"flex gap-2"},ae=["disabled"],ue={class:"overflow-x-scroll"},me={class:"highlight-first-column"},de=["onUpdate:modelValue"],pe=["onUpdate:modelValue"],he={class:"w-20 mx-auto text-center"},ce={class:"mt-16"},ge=6,ye={__name:"RoundRobin",setup(fe){const C=E(null),c=E(2),r=q([[0,4],[1,6],[2,4],[3,5]]),w=E(!1),A=q([]),U=q([]),B=q([]);G(c,()=>{x()});const N=Z(()=>{const i=Object.groupBy(A,t=>t[0]);return Object.values(i)}),x=()=>{w.value=!1,A.length=0,U.length=0,B.length=0},j=()=>{x();const t=[r[r.length-1][0]+1,Math.round(Math.random()*10)];r.push(t)},M=i=>{x(),r.splice(i,1)},O=()=>{r.forEach(i=>{i[0]=0})};let Q=null,V=-1;const g=(i,t)=>{const n=t.map(s=>`P${s[0]}`);for(;n.length<6;)n.push("-");const a=n.join(",");(a!==Q||i!==V)&&(A.push([i,n]),Q=a,V=i)},H=(i,t)=>{const n=i.slice();U.push([t,n])},I=()=>{if(!C.value.checkValidity())return C.value.reportValidity();x(),w.value=!0;const t=Number(c.value);let n=1;const a=r.map(f=>[n++,f[0],f[1],f[1]]),s=[];let u=0,o=null,L=0;const y=new Set;for(;;){if(g(u,s),a.forEach(m=>{const[b,P]=m;P===u&&!y.has(b)&&(s.push(m),g(u,s),y.add(b))}),!o&&s.length>0&&(o=s.shift(),g(u,s),H(o,u),L=Math.min(t,o[3])),o&&(o[3]-=1,L-=1),u++,o){const m=o;m[3]===0?(B.push([m[0],u]),o=null):L===0&&(o=null,a.forEach(b=>{const[P,z]=b;z===u&&!y.has(P)&&(s.push(b),g(u,s),y.add(P))}),s.push(m),g(u,s))}const f=a.every(m=>m[3]===0);if(!o&&s.length===0&&f)break}};return(i,t)=>(p(),v(_,null,{[D(W).howItWorks.id]:T(()=>[e("div",ne,[t[2]||(t[2]=e("p",null,[l(" The "),e("span",{class:"text-main"},"Round Robin Algorithm"),l(" is a widely used CPU scheduling method, particularly effective in time-sharing systems. Its main objective is to allocate CPU time fairly among all running processes, ensuring that each one receives regular access to the processor. ")],-1)),t[3]||(t[3]=e("h2",{class:"mt-10 text-xl font-semibold"}," How a Queue Works ",-1)),t[4]||(t[4]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),t[5]||(t[5]=e("p",null,[l(" Before learning about how the round robin algorithm operates, basic knowledge about a "),e("span",{class:"text-main"},"queue"),l(" is needed. ")],-1)),t[6]||(t[6]=e("p",null,[l(" A queue is a data structure used to maintain a "),e("span",{class:"text-main"},"first come first serve"),l(" order among its items, similar to how an actual queue works, for example, at a cashier in a grocer. Customers who enter the queue first will scan their items first. ")],-1)),t[7]||(t[7]=e("p",null," To illustrate this, consider the following queue with with 4 empty slots: ",-1)),d(h,{src:"/algorithms/cpu-scheduling/round-robin/empty-queue.svg",class:"max-w-xs",caption:"An Empty Queue"}),t[8]||(t[8]=e("p",null," When an item enters the queue, it goes in from the entry point and tries to get as close as it can to the exit point: ",-1)),d(h,{src:"/algorithms/cpu-scheduling/round-robin/adding-items-to-queue.svg",class:"max-w-xs",caption:"Process 1 (P1) and 2 (P2) Entering the Queue"}),t[9]||(t[9]=e("p",null," When an item is needed from the queue, it leaves from the exit point: ",-1)),d(h,{src:"/algorithms/cpu-scheduling/round-robin/item-leaving-queue.svg",class:"max-w-xl",caption:"Process 1 (P1) Leaving the Queue"}),t[10]||(t[10]=e("h2",{class:"mt-10 text-xl font-semibold"}," How the Algorithm Works ",-1)),t[11]||(t[11]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),t[12]||(t[12]=e("p",null,[l(" The round robin algorithm uses a queue internally to keep track of which processes arrived first, and thus need to be processed first. As processes arrive (based on their "),e("span",{class:"text-main"},"arrival time"),l("), they enter the queue and wait to be processed. ")],-1)),t[13]||(t[13]=e("p",null,[l(" When a process enters the CPU for processing, it can only be processed for a certain amount of time (known as "),e("span",{class:"text-main"},"time slice"),l(" or "),e("span",{class:"text-main"},"time quantum"),l(") before it has to leave and go to the back of the queue. This ensures that a large processes do not dominate the CPU. ")],-1)),t[14]||(t[14]=e("p",null," Lets look at a real example with a time slice of 2: ",-1)),t[15]||(t[15]=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Process ID:"),e("th",null,"Arrival Time:"),e("th",null,"Burst Time:")])]),e("tbody",null,[e("tr",null,[e("td",null,"P1"),e("td",null,"0"),e("td",null,"4")]),e("tr",null,[e("td",null,"P2"),e("td",null,"1"),e("td",null,"2")]),e("tr",null,[e("td",null,"P3"),e("td",null,"2"),e("td",null,"3")])])],-1)),t[16]||(t[16]=e("p",null,[l(" The "),e("span",{class:"text-main"},"arrival time"),l(" column tells us at what time a process enters the queue. The "),e("span",{class:"text-main"},"burst time"),l(" tells us the total time that process needs to be in the CPU before it is completed. ")],-1)),t[17]||(t[17]=e("p",null," Consider the following queue and CPU: ",-1)),d(h,{src:"/algorithms/cpu-scheduling/round-robin/queue-and-cpu.svg",class:"max-w-xl",caption:"An Example Empty Queue With 3 Slots, and an Empty CPU"}),t[18]||(t[18]=e("p",null," Our clock starts at 0ms. At 0ms, process 1 (P1) arrives and enters the queue. Since the CPU is currently empty and idle, P1 then leaves the queue and enters the CPU to be processed for a maximum of 2ms (the time slice): ",-1)),d(h,{src:"/algorithms/cpu-scheduling/round-robin/0ms-example-state.svg",class:"max-w-lg",caption:"P1 Enters the Queue, Leaves the Queue, and Enters the CPU"}),t[19]||(t[19]=e("p",null," At 1ms, the time remaining in the time slice is 1ms, so the process in the CPU can still be processed for 1ms longer and thus, nothing changes besides the remaining burst time of the process (since it has been processed for 1ms): ",-1)),t[20]||(t[20]=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Process ID:"),e("th",null,"Burst Time:"),e("th",null,"Remaining Burst Time:")])]),e("tbody",null,[e("tr",null,[e("td",null,"P1"),e("td",null,"4"),e("td",null,"4ms - 1ms = 3ms")])])],-1)),t[21]||(t[21]=e("p",null," However, at 1ms, P2 arrives and must enter the queue, therefore the queue is updated and P2 goes in: ",-1)),d(h,{src:"/algorithms/cpu-scheduling/round-robin/1ms-example-state.svg",class:"max-w-lg",caption:"P2 Enters the Queue"}),t[22]||(t[22]=e("p",null," At 2ms, multiple things happen. Firstly, P3 arrives at 3ms, and must enter the queue. Then, since the time remaining in the time slice is now 0ms, it needs to be restarted back to 2ms and P1 must leave the CPU to free it for the next process. ",-1)),t[23]||(t[23]=e("p",null," Finally, P2 needs to leave the queue and enter the CPU for processing, since the CPU is now idle. ",-1)),d(h,{src:"/algorithms/cpu-scheduling/round-robin/2ms-example-state.svg",class:"max-w-lg",caption:"P3 Enters the Queue, P1 Goes to the Back of the Queue, and P2 Enters the CPU"}),t[24]||(t[24]=e("p",null," Since P1 was processed for 1ms longer, its remaining burst time is updated again: ",-1)),t[25]||(t[25]=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Process ID:"),e("th",null,"Burst Time:"),e("th",null,"Remaining Burst Time:")])]),e("tbody",null,[e("tr",null,[e("td",null,"P1"),e("td",null,"4"),e("td",null,"3ms - 1ms = 2ms")])])],-1)),t[26]||(t[26]=e("p",null," This goes on until all processes have a remaining burst time of 0, and there are no more processes in the queue. Once this occurs, the algorithm will simply wait until more processes arrive and enter the queue. ",-1)),d(le,{alertStyle:"note"},{default:T(()=>t[1]||(t[1]=[e("div",{class:"space-y-4"},[e("p",null," This implementation of the round robin algorithm is biased towards arriving processes rather than completed processes. This means that if a process arrives and another process finishes during the same millisecond, the process which has arrived will enter the queue first. "),e("p",null," Only after the arriving process(es) are added to the queue, will the finished process leave the CPU and go to the back of the queue. ")],-1)])),_:1,__:[1]}),t[27]||(t[27]=e("h2",{class:"mt-10 text-xl font-semibold"}," How To Calculate Additional Metrics ",-1)),t[28]||(t[28]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),t[29]||(t[29]=e("p",null,[l(" Additional details may also be needed to measure the performance of each process in the operating system, such as "),e("span",{class:"text-main"},"waiting time"),l(" and "),e("span",{class:"text-main"},"turnaround time"),l(". ")],-1)),t[30]||(t[30]=e("p",null," Waiting time is the total time that a process spends in the queue, and turnaround time is the total time taken from when a process arrives to when it completes execution. The following formulae are used to calculate each value respectively: ",-1)),t[31]||(t[31]=e("p",{class:"italic"}," Turnaround Time = Completion Time - Arrival Time ",-1)),t[32]||(t[32]=e("p",{class:"italic"}," Waiting Time = Turnaround Time - Burst Time ",-1))])]),[D(W).visualizer.id]:T(()=>[e("div",null,[t[37]||(t[37]=e("h1",{class:"mb-4 text-xl font-semibold"}," Step By Step Illustration ",-1)),t[38]||(t[38]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),e("form",{ref_key:"form",ref:C,class:"w-full space-y-4 gap-x-4"},[e("div",ie,[e("div",oe,[t[33]||(t[33]=e("label",{class:"font-medium"},"Time Slice:",-1)),R(e("input",{type:"number",class:"w-full field sm:w-60","onUpdate:modelValue":t[0]||(t[0]=n=>c.value=n),min:"1",max:"20",required:""},null,512),[[S,c.value]])]),e("div",re,[e("button",{class:"btn",type:"button",onClick:k(O,["prevent"])}," Set All Arrival Times to Zero "),e("button",{class:"btn",type:"button",onClick:k(j,["prevent"]),disabled:r.length===ge}," Add Row ",8,ae)])]),e("div",ue,[e("table",null,[t[34]||(t[34]=e("thead",null,[e("tr",null,[e("th",null,"Process"),e("th",null,"Arrival Time"),e("th",null,"Burst Time"),e("th")])],-1)),e("tbody",me,[(p(!0),$(K,null,J(r,(n,a)=>(p(),$("tr",{key:a},[e("td",null," P"+X(a+1),1),e("td",null,[R(e("input",{type:"number",min:"0",max:"10",required:"","onUpdate:modelValue":s=>n[0]=s},null,8,de),[[S,n[0]]])]),e("td",null,[R(e("input",{type:"number",min:"1",max:"20",required:"","onUpdate:modelValue":s=>n[1]=s},null,8,pe),[[S,n[1]]])]),e("td",he,[r.length>1?(p(),v(ee,{key:0,onClick:s=>M(a)},null,8,["onClick"])):F("",!0)])]))),128))])])]),e("button",{onClick:k(I,["prevent"]),class:"btn",type:"submit"}," Run Algorithm ")],512),e("div",ce,[t[36]||(t[36]=e("h3",{class:"mb-2 text-lg font-medium"},"Results:",-1)),w.value?(p(),v(te,{key:0,queueLog:N.value,processLog:U,quantum:Number(c.value)},null,8,["queueLog","processLog","quantum"])):F("",!0),w.value?(p(),v(se,{key:1,processData:r,"finished-processes":B},null,8,["processData","finished-processes"])):(p(),v(Y,{key:2},{default:T(()=>[t[35]||(t[35]=e("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),e("button",{onClick:k(I,["prevent"]),class:"btn"}," Run Algorithm ")]),_:1}))])])]),_:2},1024))}};export{ye as default};
