import{r as _,a as V,c as m,b as l,f as e,e as d,d as F,k as h,l as k,m as N,g as f,i as p,n as B,F as I,j as $,u as a,o as i,t as j,h as g,v as y,I as L}from"./index-DVmO8pqR.js";import{_ as M,a as D,T as E}from"./Figure-BjWnhPfj.js";import{_ as O,a as G}from"./ProcessDetails-CkTdw_H4.js";import{_ as Q}from"./Alert-DXw83yxL.js";import{u as Z}from"./useScheduler-DnuRjPNN.js";const H={class:"mb-10 space-y-4"},J={class:"flex items-end gap-4"},K={class:"flex flex-wrap justify-end w-full gap-2"},W=["disabled"],X={class:"overflow-x-scroll"},Y={class:"highlight-first-column"},ee={class:"flex items-center"},te=["onUpdate:modelValue"],se=["onUpdate:modelValue"],re=["onUpdate:modelValue"],oe={class:"w-20 mx-auto text-center"},ie=["onClick"],P=6,ce={__name:"Priority",setup(ne){const b=_(null),r=V([[0,4,1],[0,6,2],[0,4,3],[0,5,4]]),u=_(!1),C=m(()=>{let s=1;return r.slice().map(t=>[s++,...t,t[1]])}),v=m(()=>({runtimeProcesses:C,form:b,hasAlgorithmBeenRan:u,sortFn:(t,o)=>t[3]-o[3]})),{runAlgorithm:w,resetAlgorithmResults:x,queueLog:S,processLog:q,finishedProcesses:R}=Z(),A=m(()=>{const s=Object.groupBy(S,t=>t[0]);return Object.values(s)}),T=()=>{x();const s=r[r.length-1],t=s[2]+1<=10?s[2]+1:s[2],o=[s[0]+1,Math.round(Math.random()*10),t];r.push(o)},U=s=>{x(),r.splice(s,1)},z=()=>{r.forEach(s=>{s[0]=0})};return(s,t)=>(i(),l("div",null,[t[7]||(t[7]=e("h1",{class:"mb-4 text-2xl font-semibold"}," Priority Scheduling (Non-Preemptive) ",-1)),t[8]||(t[8]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),e("div",H,[t[5]||(t[5]=e("p",null,[e("span",{class:"text-main"},"Priority Scheduling"),N(" is a CPU scheduling technique in which every process is assigned a priority value, and the CPU always executes the highest-priority process available at any given time. ")],-1)),d(Q,{"alert-style":"warning"},{default:f(()=>t[2]||(t[2]=[e("p",null," This is a non-preemptive version of this algorithm, meaning that processes are not interrupted until they are completed, similar to how the first come first serve (FCFS) algorithm works. ",-1)])),_:1,__:[2]}),t[6]||(t[6]=F('<p> Unlike algorithms like <span class="text-main">FCFS</span> or <span class="text-main">Round Robin</span> that rely on arrival time or time slicing for fair process distrbution, Priority Scheduling adds a layer of control, where processes in the queue are sorted based on which one is more important, allowing the system to control which processes run first. </p><p> In most implementations, the priorities are given to processes in ascending order, meaning that a process with a priority of 1 is more important than a process with a priority of 3. </p><h1 class="mb-4 text-xl font-semibold"> Understanding the Process </h1><hr class="mb-4 border-neutral-800"><ol class="grid grid-cols-1 space-y-4 gap-x-4"><li class="p-4 border rounded-md border-zinc-700"><span class="font-medium text-main"> Step 1: Gather process info </span><p> Each process needs to have an arrival time (when the process enters the ready queue), a burst time (how long the process needs), and an assigned priority (how important the process is). </p></li><li class="p-4 border rounded-md border-zinc-700"><span class="font-medium text-main"> Step 2: Track the current time </span><p> Initialize the system clock (usually starting at 0). This value will increase in small steps, or 1ms for our case, to simulate real-time execution of the processes. </p></li><li class="p-4 border rounded-md border-zinc-700"><span class="font-medium text-main"> Step 3: Check for new arrivals </span><p> At each time step, check if any new processes have arrived (i.e., their arrival time matches the current time). Add those to the ready queue. </p></li><li class="p-4 border rounded-md border-zinc-700"><span class="font-medium text-main"> Step 4: Pick the highest priority process </span><p> If the CPU is idle and there are processes in the ready queue, select the one with the highest priority (lowest number). Note that if multiple processes have the same priority, then the one that arrived first will be chosen by the CPU. </p></li><li class="p-4 border rounded-md border-zinc-700"><span class="font-medium text-main"> Step 5: Run the process for 1ms (or 1 unit) </span><p> Run the process for 1ms, then repeat step 3 to add any processes that may have arrived to the ready queue. This is to ensure that the queue is up to date. </p></li><li class="p-4 border rounded-md border-zinc-700"><span class="font-medium text-main"> Step 6: Run the process until completed </span><p> Repeat step 5 until the entire process is completed. This is the non-preemptive version of the algorithm, so there will be no interrupts; the process is fully executed. </p></li><li class="p-4 border rounded-md border-zinc-700"><span class="font-medium text-main"> Step 7: Repeat step 3 to step 7 until all processes are finished </span><p> Repeat all the steps stated for each process until the CPU is idle, and the ready queue is empty. For additional metrics, such as the waiting time and turnaround time, make sure to record the finish time of each process. </p></li></ol>',5)),d(M,{src:"/algorithms/cpu-scheduling/priority/priority-scheduling.svg",caption:"Priority Scheduling Algorithm"}),e("form",{ref_key:"form",ref:b,class:"w-full space-y-4 gap-x-4"},[e("div",J,[e("div",K,[e("button",{class:"btn",type:"button",onClick:p(z,["prevent"])}," Set All Arrival Times to Zero "),e("button",{class:B(["btn",{disabled:r.length===P}]),type:"button",onClick:p(T,["prevent"]),disabled:r.length===P}," Add Row ",10,W)])]),e("div",X,[e("table",null,[t[3]||(t[3]=e("thead",null,[e("tr",null,[e("th",null,"Process"),e("th",null,"Arrival Time"),e("th",null,"Burst Time"),e("th",null,"Priority"),e("th")])],-1)),e("tbody",Y,[(i(!0),l(I,null,$(r,(o,c)=>(i(),l("tr",{key:c},[e("td",ee,[e("span",null," P"+j(c+1),1)]),e("td",null,[g(e("input",{type:"number",min:"0",max:"10",required:"","onUpdate:modelValue":n=>o[0]=n},null,8,te),[[y,o[0]]])]),e("td",null,[g(e("input",{type:"number",min:"1",max:"20",required:"","onUpdate:modelValue":n=>o[1]=n},null,8,se),[[y,o[1]]])]),e("td",null,[g(e("input",{type:"number",min:"1",max:"10",required:"","onUpdate:modelValue":n=>o[2]=n},null,8,re),[[y,o[2]]])]),e("td",oe,[r.length>1?(i(),l("div",{key:0,class:"flex items-center justify-center duration-100 border border-transparent rounded-md cursor-pointer bg-zinc-700 aspect-square w-7 group hover:border-rose-600 active:translate-y-1",onClick:n=>U(c)},[d(a(L),{class:"text-rose-500",tag:"span",size:"20px"},{default:f(()=>[d(a(E))]),_:1})],8,ie)):k("",!0)])]))),128))])])]),e("button",{onClick:t[0]||(t[0]=p(()=>a(w)(v.value),["prevent"])),class:"btn",type:"submit"}," Run Algorithm ")],512),u.value?(i(),h(O,{key:0,"process-log":a(q),"queue-log":A.value,quantum:1},null,8,["process-log","queue-log"])):k("",!0),u.value?(i(),h(G,{key:1,"process-data":r,"finished-processes":a(R)},null,8,["process-data","finished-processes"])):(i(),h(D,{key:2},{default:f(()=>[t[4]||(t[4]=e("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),e("button",{onClick:t[1]||(t[1]=p(()=>a(w)(v.value),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[4]}))])]))}};export{ce as default};
