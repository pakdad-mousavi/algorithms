import{r as k,a as F,c as f,b as u,u as i,t as P,d as l,e,j as q,g as d,h as g,i as I,F as B,k as p,l as c,o as n,m as $,f as y,v as b,I as N}from"./index-CE2k5yp4.js";import{_ as j,a as L,b as M,T as D}from"./Figure-CHKq4HFN.js";import{_ as E,a as O}from"./ProcessDetails-EPyblIfa.js";import{_ as G}from"./Alert-DKm2gy0g.js";import{u as Q}from"./useScheduler-XDncicET.js";const W={class:"mb-10 space-y-4"},Z={class:"mb-10 space-y-4"},H={class:"flex items-end gap-4"},J={class:"flex flex-wrap justify-end w-full gap-2"},K=["disabled"],X={class:"overflow-x-scroll"},Y={class:"highlight-first-column"},ee=["onUpdate:modelValue"],te=["onUpdate:modelValue"],se=["onUpdate:modelValue"],re={class:"w-20 mx-auto text-center"},oe=["onClick"],ie=6,ce={__name:"Priority",setup(ne){const v=k(null),r=F([[0,4,1],[0,6,2],[0,4,3],[0,5,4]]),m=k(!1),C=f(()=>{let s=1;return r.slice().map(t=>[s++,...t,t[1]])}),w=f(()=>({runtimeProcesses:C,form:v,hasAlgorithmBeenRan:m,sortFn:(t,o)=>t[3]-o[3]})),{runAlgorithm:_,resetAlgorithmResults:x,queueLog:R,processLog:S,finishedProcesses:A}=Q(),T=f(()=>{const s=Object.groupBy(R,t=>t[0]);return Object.values(s)}),U=()=>{x();const s=r[r.length-1],t=s[2]+1<=10?s[2]+1:s[2],o=[s[0]+1,Math.round(Math.random()*10),t];r.push(o)},z=s=>{x(),r.splice(s,1)},V=()=>{r.forEach(s=>{s[0]=0})};return(s,t)=>(n(),u(M,null,{[i(P).howItWorks.id]:l(()=>[e("div",W,[t[3]||(t[3]=e("p",null,[e("span",{class:"text-main"},"Priority Scheduling"),c(" is a CPU scheduling technique in which every process is assigned a priority value, and the CPU always executes the highest-priority process available at any given time. ")],-1)),p(G,{"alert-style":"warning"},{default:l(()=>t[2]||(t[2]=[e("p",null," This is a non-preemptive version of this algorithm, meaning that processes are not interrupted until they are completed, similar to how the first come first serve (FCFS) algorithm works. ",-1)])),_:1,__:[2]}),t[4]||(t[4]=e("p",null,[c(" Unlike algorithms like "),e("span",{class:"text-main"},"FCFS"),c(" or "),e("span",{class:"text-main"},"Round Robin"),c(" that rely on arrival time or time slicing for fair process distrbution, Priority Scheduling adds a layer of control, where processes in the queue are sorted based on which one is more important, allowing the system to control which processes run first. ")],-1)),t[5]||(t[5]=e("p",null," In most implementations, the priorities are given to processes in ascending order, meaning that a process with a priority of 1 is more important than a process with a priority of 3. ",-1)),t[6]||(t[6]=e("h1",{class:"mb-4 text-xl font-semibold"}," Understanding the Process ",-1)),t[7]||(t[7]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),t[8]||(t[8]=e("ol",{class:"grid grid-cols-1 space-y-4 gap-x-4"},[e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 1: Gather process info "),e("p",null," Each process needs to have an arrival time (when the process enters the ready queue), a burst time (how long the process needs), and an assigned priority (how important the process is). ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 2: Track the current time "),e("p",null," Initialize the system clock (usually starting at 0). This value will increase in small steps, or 1ms for our case, to simulate real-time execution of the processes. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 3: Check for new arrivals "),e("p",null," At each time step, check if any new processes have arrived (i.e., their arrival time matches the current time). Add those to the ready queue. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 4: Pick the highest priority process "),e("p",null," If the CPU is idle and there are processes in the ready queue, select the one with the highest priority (lowest number). Note that if multiple processes have the same priority, then the one that arrived first will be chosen by the CPU. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 5: Run the process for 1ms (or 1 unit) "),e("p",null," Run the process for 1ms, then repeat step 3 to add any processes that may have arrived to the ready queue. This is to ensure that the queue is up to date. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 6: Run the process until completed "),e("p",null," Repeat step 5 until the entire process is completed. This is the non-preemptive version of the algorithm, so there will be no interrupts; the process is fully executed. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 7: Repeat step 3 to step 7 until all processes are finished "),e("p",null," Repeat all the steps stated for each process until the CPU is idle, and the ready queue is empty. For additional metrics, such as the waiting time and turnaround time, make sure to record the finish time of each process. ")])],-1)),p(L,{src:"/algorithms/cpu-scheduling/priority/priority-scheduling.svg",caption:"Priority Scheduling Algorithm"})])]),[i(P).visualizer.id]:l(()=>[e("div",Z,[e("form",{ref_key:"form",ref:v,class:"w-full space-y-4 gap-x-4"},[e("div",H,[e("div",J,[e("button",{class:"btn",type:"button",onClick:d(V,["prevent"])}," Set All Arrival Times to Zero "),e("button",{class:"btn",type:"button",onClick:d(U,["prevent"]),disabled:r.length===ie}," Add Row ",8,K)])]),e("div",X,[e("table",null,[t[9]||(t[9]=e("thead",null,[e("tr",null,[e("th",null,"Process"),e("th",null,"Arrival Time"),e("th",null,"Burst Time"),e("th",null,"Priority"),e("th")])],-1)),e("tbody",Y,[(n(!0),g(B,null,I(r,(o,h)=>(n(),g("tr",{key:h},[e("td",null," P"+$(h+1),1),e("td",null,[y(e("input",{type:"number",min:"0",max:"10",required:"","onUpdate:modelValue":a=>o[0]=a},null,8,ee),[[b,o[0]]])]),e("td",null,[y(e("input",{type:"number",min:"1",max:"20",required:"","onUpdate:modelValue":a=>o[1]=a},null,8,te),[[b,o[1]]])]),e("td",null,[y(e("input",{type:"number",min:"1",max:"10",required:"","onUpdate:modelValue":a=>o[2]=a},null,8,se),[[b,o[2]]])]),e("td",re,[r.length>1?(n(),g("div",{key:0,class:"flex items-center justify-center duration-100 border border-transparent rounded-md cursor-pointer bg-zinc-700 aspect-square w-7 group hover:border-rose-600 active:translate-y-1",onClick:a=>z(h)},[p(i(N),{class:"text-rose-500",tag:"span",size:"20px"},{default:l(()=>[p(i(D))]),_:1})],8,oe)):q("",!0)])]))),128))])])]),e("button",{onClick:t[0]||(t[0]=d(()=>i(_)(w.value),["prevent"])),class:"btn",type:"submit"}," Run Algorithm ")],512),m.value?(n(),u(E,{key:0,"process-log":i(S),"queue-log":T.value,quantum:1},null,8,["process-log","queue-log"])):q("",!0),m.value?(n(),u(O,{key:1,"process-data":r,"finished-processes":i(A)},null,8,["process-data","finished-processes"])):(n(),u(j,{key:2},{default:l(()=>[t[10]||(t[10]=e("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),e("button",{onClick:t[1]||(t[1]=d(()=>i(_)(w.value),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[10]}))])]),_:2},1024))}};export{ce as default};
