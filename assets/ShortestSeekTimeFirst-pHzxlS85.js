import{k as g,D as q,E as A,f as c,u as S,G as x,w as k,a as t,c as f,s as T,v as y,j as $,F as B,z as R,e as r,J as l,o,y as N}from"./index-Nx0vkye7.js";import{_ as D,a,b as E,c as M}from"./EmptySpace-CeTGyuHZ.js";import{_ as I,r as U}from"./SeekTimeGraph-CvTv8kP2.js";const z={class:"mb-10 space-y-4"},W={class:"mb-10 space-y-4"},H={class:"flex items-end gap-4"},O={class:"flex flex-col flex-1 gap-2"},Q=["disabled"],G=["onUpdate:modelValue"],P={class:"w-20 mx-auto text-center"},j={key:0},b=199,F=0,Y={__name:"ShortestSeekTimeFirst",setup(J){const m=g(null),s=q([98,183,37,122,14,124,65,67]),u=g(53),d=q({orderedRequests:null,totalSeekTime:null}),h=g(!1);A([s,u],()=>{h.value=!1});const C=()=>{const i=Math.round(Math.random()*b);s.push(i)},V=i=>{s.splice(i,1)},v=()=>{if(!m.value.checkValidity())return m.value.reportValidity();const{orderedRequests:e,totalSeekTime:n}=U(u.value,s.slice(),"sstf");d.orderedRequests=e,d.totalSeekTime=n,h.value=!0};return(i,e)=>(o(),c(E,null,{[S(x).howItWorks.id]:k(()=>[t("div",z,[e[5]||(e[5]=t("p",null,[l(" The "),t("span",{class:"text-main"},"Shortest Seek Time First (SSTF)"),l(" algorithm is a disk scheduling algorithm used to minimize the "),t("span",{class:"text-main"},"seek time"),l(" when responding to incoming disk requests. It operates by responding to the closest request to the current head. ")],-1)),t("p",null,[e[3]||(e[3]=l(" This is a disk scheduling algorithm, which requires some basic knowledge about a hard disk. To learn more about disk architecture, see the ")),t("span",{class:"cursor-pointer text-main",onClick:e[0]||(e[0]=n=>i.$router.push("/disk-scheduling/first-come-first-serve"))},"First Come First Serve (FCFS)"),e[4]||(e[4]=l(" algorithm. "))]),e[6]||(e[6]=t("h2",{class:"mt-10 text-xl font-semibold"}," How the Algorithm Works ",-1)),e[7]||(e[7]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[8]||(e[8]=t("p",null,[l(" The SSTF algorithm is an example of a "),t("span",{class:"text-main"},"greedy algorithm"),l(", meaning that it chooses the request with the shortest immediate seek time, hoping that it leads to the most optimal solution. ")],-1)),e[9]||(e[9]=t("p",null," To put this into perspective, consider the following disk request queue, along with the new order in which the requests will be served: ",-1)),r(a,{src:"/algorithms/disk-scheduling/shortest-seek-time-first/disk-requests.svg",class:"max-w-lg",caption:"A Sample Disk Request Queue"}),e[10]||(e[10]=t("p",null," The SSTF algorithm calculates the distance between the current head and each of the disk requests, by subtracting the larger value from the smaller value (to avoid negative distances). ",-1)),e[11]||(e[11]=t("p",null," For example, to calculate the distance from the head (53) to the first request (98), the larger value would need to be subtracted: 98 - 53 = 45. But to calculate the distance from the head and to the third request (37), the calculation would be 53 - 37 = 16. ",-1)),e[12]||(e[12]=t("p",null," It then chooses the disk request which resulted in the smallest distance from the current head, i.e., the disk request with the shortest seek time from the current head. ",-1)),r(a,{src:"/algorithms/disk-scheduling/shortest-seek-time-first/calculating-sst-request-primary.svg",class:"max-w-lg",caption:"Calculating Which Request Currently Has the Shortest Seek Time"}),e[13]||(e[13]=t("p",null," Once the request is served, the head will be at a new position (65), and the process will be repeated again, with the requested which have not yet been served and the new head: ",-1)),r(a,{src:"/algorithms/disk-scheduling/shortest-seek-time-first/calculating-sst-request-secondary.svg",class:"max-w-lg",caption:"Calculating the Next Request With the Shortest Seek Time"}),e[14]||(e[14]=t("p",null," Once the process is repeated for all of the remaining disk requests in the queue, we will get the order in which the processes have been served: ",-1)),r(a,{src:"/algorithms/disk-scheduling/shortest-seek-time-first/final-order.svg",class:"max-w-lg",caption:"The Final Order of Disk Requests Served"}),e[15]||(e[15]=t("p",null,[l(" To visualize this using a "),t("span",{class:"text-main"},"seek time graph"),l(", the requests will be plotted in the final order resulting from the SSTF algorithm, and the total seek time can be calculated like so: ")],-1)),r(a,{src:"/algorithms/disk-scheduling/shortest-seek-time-first/sstf-algorithm.svg",caption:"The Seek Time Graph for the SSTF Algorithm"})])]),[S(x).visualizer.id]:k(()=>[t("div",W,[e[19]||(e[19]=t("h1",{class:"mb-4 text-xl font-semibold"}," Step By Step Illustration ",-1)),e[20]||(e[20]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),t("form",{class:"space-y-4",ref_key:"form",ref:m},[t("div",H,[t("div",O,[e[16]||(e[16]=t("label",{class:"font-medium"},"Current Head Position:",-1)),T(t("input",{type:"number",class:"field",min:F,max:b,"onUpdate:modelValue":e[1]||(e[1]=n=>u.value=n)},null,512),[[y,u.value]])]),t("button",{type:"button",class:"btn",disabled:s.length===15,onClick:C},"Add Row",8,Q)]),t("table",null,[e[17]||(e[17]=t("thead",null,[t("tr",null,[t("th",null,"Disk Requests"),t("th")])],-1)),t("tbody",null,[(o(!0),f(B,null,$(s,(n,p)=>(o(),f("tr",null,[t("td",null,[T(t("input",{type:"number","onUpdate:modelValue":w=>s[p]=w,min:F,max:b},null,8,G),[[y,s[p]]])]),t("td",P,[s.length>1?(o(),c(M,{key:0,onClick:w=>V(p)},null,8,["onClick"])):N("",!0)])]))),256))])]),t("button",{type:"submit",class:"btn",onClick:R(v,["prevent"])},"Run Algorithm")],512),e[21]||(e[21]=t("h2",{class:"mt-10 text-xl font-semibold"}," Results ",-1)),e[22]||(e[22]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),h.value?(o(),f("div",j,[r(I,{"ordered-requests":d.orderedRequests,"total-seek-time":d.totalSeekTime},null,8,["ordered-requests","total-seek-time"])])):(o(),c(D,{key:1},{default:k(()=>[e[18]||(e[18]=t("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),t("button",{onClick:e[2]||(e[2]=R(()=>v(),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[18]}))])]),_:2},1024))}};export{Y as default};
