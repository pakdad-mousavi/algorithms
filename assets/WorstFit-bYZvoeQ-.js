import{k as g,D as B,E as P,f as h,u as v,G as V,w,a as t,s as d,v as x,c as p,j as I,F as z,z as D,e as M,A as m,h as U,o as a,J as S,t as $,y as F}from"./index-Dtu6NS1_.js";import{_ as N,a as K,b as _}from"./EmptySpace-Dnpstv_X.js";import{_ as L,r as W}from"./memory-management-CIY9_YIL.js";import{_ as q}from"./TrashButton-DluxHDKH.js";import"./Alert-DVQcyZlP.js";const E={class:"mb-10 space-y-4"},j={class:"mb-10 space-y-4"},H={class:"flex flex-wrap items-end gap-4"},G={class:"flex flex-col gap-2"},J={class:"flex flex-col flex-1 gap-2"},O={class:"flex gap-2"},Q=["disabled"],X={class:"overflow-x-scroll"},Y=["onUpdate:modelValue"],Z=["onUpdate:modelValue"],ee=["value"],te=["onUpdate:modelValue"],oe={class:"w-20 mx-auto text-center"},me={__name:"WorstFit",setup(se){const T=U(),y=g(null),c=g(4),u=g(100),l=B([{isAllocation:!0,pid:1,size:30},{isAllocation:!0,pid:2,size:20},{isAllocation:!0,pid:3,size:20},{isAllocation:!1,pid:2},{isAllocation:!0,pid:4,size:15}]),b=B({isSuccessful:!1,memoryLog:[]}),f=g(!1);P([l,u],()=>{f.value=!1});const C=n=>{l.splice(n,1)},R=()=>{const n=c.value,e=new Set(l.filter(o=>o.isAllocation).map(o=>o.pid)),s=new Set(l.filter(o=>!o.isAllocation).map(o=>o.pid)),r=[...e].filter(o=>!s.has(o));if(e.size<n){let o=null;for(let i=1;i<=n;i++)if(!e.has(i)){o=i;break}const A={isAllocation:!0,pid:o,size:10};l.push(A)}else if(r.length>0){const o=Math.floor(Math.random()*r.length),i={isAllocation:!1,pid:r[o]};l.push(i)}},k=()=>{if(!y.value.checkValidity())return y.value.reportValidity();const{isSuccessful:e,memoryLog:s}=W(l,u.value,"worstFit");b.isSuccessful=e,b.memoryLog=s,f.value=!0};return(n,e)=>(a(),h(_,null,{[v(V).howItWorks.id]:w(()=>[t("div",E,[e[7]||(e[7]=t("p",null,[m(" The "),t("span",{class:"text-main"},"Worst Fit Algorithm"),m(" is a memory allocation algorithm, which is also used in used in dynamic memory management. It's job is also to manage free space in the main memory. It works by allocating the largest free block available in memory to the process requesting memory. ")],-1)),t("p",null,[e[4]||(e[4]=m(" As memory is allocated and deallocated to and from processes, the memory becomes ")),e[5]||(e[5]=t("span",{class:"text-main"},"fragmented",-1)),e[6]||(e[6]=m(". To understand how memory works and how fragmentation occurs, see the ")),t("span",{class:"cursor-pointer text-main",onClick:e[0]||(e[0]=s=>v(T).push("/memory-management/first-fit"))}," First Fit Algorithm. ")]),e[8]||(e[8]=t("h2",{class:"mt-10 text-xl font-semibold"}," How It Works ",-1)),e[9]||(e[9]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[10]||(e[10]=t("p",null,[m(" The worst fit algorithm goes through all free blocks of memory which are large enough for the request, and from those blocks, chooses the largest one. Its goal is to reduce "),t("span",{class:"text-main"},"external fragmentation"),m(" by breaking up memory into larger blocks which may be reused more often later. ")],-1)),e[11]||(e[11]=t("p",null," Lets say we have allocated 50KB to process 1, then 80KB to process 2, and finally 10KB to process 3. Between each process, there's 20KB, 40KB, and 50KB worth of free space respectively: ",-1)),M(K,{src:"/algorithms/memory-management/worst-fit/example-allocation.svg",class:"max-w-2xl",caption:"Example Memory Allocation"}),e[12]||(e[12]=t("p",null," The worst fit algorithm would look amongst all the free blocks of memory that are large enough for the process (40KB and 50KB), and choose the largest block amongst those. By choosing the largest free block, it will leave the most amount of free space possible, in hopes that it can be reused later: ",-1)),M(K,{src:"/algorithms/memory-management/worst-fit/worst-fit-algorithm.svg",class:"max-w-2xl",caption:"How the Worst Fit Algorithm Chooses a Memory Block"})])]),[v(V).visualizer.id]:w(()=>[t("div",j,[e[18]||(e[18]=t("h2",{class:"text-xl font-semibold"}," Step by Step Illustration ",-1)),e[19]||(e[19]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),t("form",{class:"space-y-4",ref_key:"form",ref:y},[t("div",H,[t("div",G,[e[13]||(e[13]=t("label",{class:"font-medium"},"Number of Processes:",-1)),d(t("input",{type:"number",class:"w-full field sm:w-60",min:"1",max:"6",required:"","onUpdate:modelValue":e[1]||(e[1]=s=>c.value=s)},null,512),[[x,c.value]])]),t("div",J,[e[14]||(e[14]=t("label",{class:"font-medium"},"Total Memory Size (KB):",-1)),d(t("input",{type:"number",class:"w-full field sm:w-60",min:"10",max:"150",required:"","onUpdate:modelValue":e[2]||(e[2]=s=>u.value=s)},null,512),[[x,u.value]])]),t("div",O,[t("button",{class:"btn",type:"button",onClick:e[3]||(e[3]=s=>R()),disabled:l.length===12}," Add Row ",8,Q)])]),t("div",X,[t("table",null,[e[16]||(e[16]=t("thead",null,[t("tr",null,[t("th",null,"Action Type"),t("th",null,"Process ID"),t("th",null,"Size (KB)"),t("th")])],-1)),t("tbody",null,[(a(!0),p(z,null,I(l,(s,r)=>(a(),p("tr",{key:r},[t("td",null,[d(t("select",{"onUpdate:modelValue":o=>s.isAllocation=o},e[15]||(e[15]=[t("option",{value:!0},"Allocation",-1),t("option",{value:!1},"Deallocation",-1)]),8,Y),[[S,s.isAllocation]])]),t("td",null,[d(t("select",{"onUpdate:modelValue":o=>s.pid=o},[(a(!0),p(z,null,I(c.value,o=>(a(),p("option",{value:o},$(o),9,ee))),256))],8,Z),[[S,s.pid]])]),t("td",null,[s.isAllocation?d((a(),p("input",{key:0,min:"10",type:"number","onUpdate:modelValue":o=>s.size=o},null,8,te)),[[x,s.size]]):F("",!0)]),t("td",oe,[l.length>1?(a(),h(q,{key:0,onClick:o=>C(r)},null,8,["onClick"])):F("",!0)])]))),128))])])]),t("button",{type:"submit",class:"btn",onClick:D(k,["prevent"])},"Run Algorithm")],512),e[20]||(e[20]=t("h2",{class:"mt-10 text-xl font-semibold"}," Results ",-1)),e[21]||(e[21]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),f.value?(a(),h(L,{key:0,"has-algorithm-been-ran":f.value,"total-memory":u.value,"alg-result":b,actions:l},null,8,["has-algorithm-been-ran","total-memory","alg-result","actions"])):(a(),h(N,{key:1},{default:w(()=>[e[17]||(e[17]=t("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),t("button",{onClick:D(k,["prevent"]),class:"btn"}," Run Algorithm ")]),_:1}))])]),_:2},1024))}};export{me as default};
