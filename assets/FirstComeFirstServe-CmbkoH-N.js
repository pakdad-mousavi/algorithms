import{r as k,a as I,c as b,b as m,d as v,T as j,o as r,e as i,f as c,g as e,h,i as o,k as p,n as E,F as L,l as N,t as O,j as T,v as S,u as a,I as $}from"./index-B2qxMY-B.js";import{_ as F,T as H,a as M}from"./Figure-KKT11UNX.js";import{_ as D,a as Q}from"./ProcessDetails-COpjYhRA.js";import{u as W}from"./useScheduler-B1BwEB5x.js";const G={key:0},Z={class:"mb-10 space-y-4"},J={key:1},K={class:"space-y-4"},X={class:"flex items-end gap-4"},Y={class:"flex flex-wrap justify-end w-full gap-2"},ee=["disabled"],te={class:"overflow-x-scroll"},se={class:"highlight-first-column"},re=["onUpdate:modelValue"],ne=["onUpdate:modelValue"],oe={class:"w-20 mx-auto text-center"},ie=["onClick"],_=6,me={__name:"FirstComeFirstServe",props:{tab:{type:String,required:!0}},setup(g){const y=k(null),s=I([[0,4],[0,6],[0,4],[0,5]]),l=k(!1),A=b(()=>{let n=1;return s.slice().map(t=>[n++,...t,t[1]])}),w=b(()=>({runtimeProcesses:A,form:y,hasAlgorithmBeenRan:l,sortFn:null})),{runAlgorithm:x,resetAlgorithmResults:C,queueLog:q,processLog:P,finishedProcesses:U}=W(),z=b(()=>{const n=Object.groupBy(q,t=>t[0]);return Object.values(n)}),B=()=>{C(l);const t=[s[s.length-1][0]+1,Math.round(Math.random()*10)];s.push(t)},V=n=>{C(l),s.splice(n,1)},R=()=>{s.forEach(n=>{n[0]=0})};return(n,t)=>(r(),m(j,null,{default:v(()=>[(r(),i("div",{key:g.tab},[g.tab==="How It Works"?(r(),i("div",G,[e("div",Z,[t[2]||(t[2]=e("p",null,[o(" The "),e("span",{class:"text-main"},"first come first serve"),o(" is one of the simplest CPU scheduling algorithms, providing a straightforward way for the CPU to handle incoming processes. ")],-1)),t[3]||(t[3]=e("p",null,[o(" As the name suggests, processes that arrive and enter the ready queue first, will be processed first. However, unlike the "),e("span",{class:"text-main"},"round robin algorithm"),o(", the CPU will be allocated entirely to that process until it is fully executed and completed. Only then will the CPU move on to the next process in the ready queue. FCFS is generally suitable for systems where the processes are short and arrive at regular intervals. ")],-1)),t[4]||(t[4]=e("p",null,[o(" However, although this is a much simpler algorithm to implement and also to understand, it may lead to longer wait times for shorter processes if a longer one arrives first. This is commonly known as the "),e("span",{class:"text-main"},"Convoy Effect"),o(", and it may lead to poor processing times in terms of average "),e("span",{class:"text-main"},"waiting times"),o(". ")],-1)),t[5]||(t[5]=e("p",null," Here's a simple analogy: the queue in front of the cashier. Customers with a basket containing a few items will be forced to wait a long time, until the customer with a trolley worth of groceries in front of them finishes scanning all their items at the cashier. ",-1)),t[6]||(t[6]=e("p",null," Regardless of the shortcomings of the FCFS algorithm, it is still one of the most well known methods and can provide a base for comparision against other algorithms. ",-1)),h(F,{src:"/algorithms/cpu-scheduling/fcfs/customer-analogy.svg",caption:"FCFS Customer Queue Analogy"}),t[7]||(t[7]=e("h1",{class:"mb-4 text-xl font-semibold"}," Understanding the Process ",-1)),t[8]||(t[8]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),t[9]||(t[9]=e("ol",{class:"grid grid-cols-1 space-y-4 gap-x-4"},[e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 1: Gather process info "),e("p",null," Each process is given an arrival time (when it enters the queue) and a burst time (how long it needs the CPU). The algorithm will be charged with running these processes one by one. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 2: Sort by arrival time "),e("p",null," The processes are sorted in the order they arrive. FCFS is all about who comes first, no jumping the line and no interruptions. By sorting the processes, it is clear in which order to run the processes. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 3: Execute each process one by one "),e("p",null," The CPU starts at time 0. The first process in the sorted list gets the CPU right away, and the rest of the processes must wait until the process in the CPU is entirely executed. Once the process is completed, the next process leaves the queue and enters the process. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 4: Calculate start and finish times "),e("p",null," For each process, record when it started and when it finished based on the burst times and the current time. These are important for later calculating the waiting time and turnaround times of the processes. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 5: Compute turnaround and waiting times "),e("p",null," Turnaround time = Finish time - Arrival time. "),e("p",null," Waiting time = Turnaround time - Burst time. "),e("p",null," These help evaluate how efficient the scheduling was. ")])],-1)),h(F,{src:"/algorithms/cpu-scheduling/fcfs/fcfs-scheduling-algorithm.svg",caption:"FCFS Scheduling Algorithm"})])])):c("",!0),g.tab==="Algorithm Visualizer"?(r(),i("div",J,[e("div",K,[t[12]||(t[12]=e("h1",{class:"mb-4 text-xl font-semibold"}," Step by Step Illustration ",-1)),t[13]||(t[13]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),e("form",{ref_key:"form",ref:y,class:"w-full space-y-4 gap-x-4"},[e("div",X,[e("div",Y,[e("button",{class:"btn",type:"button",onClick:p(R,["prevent"])}," Set All Arrival Times to Zero "),e("button",{class:E(["btn",{disabled:s.length===_}]),type:"button",onClick:p(B,["prevent"]),disabled:s.length===_}," Add Row ",10,ee)])]),e("div",te,[e("table",null,[t[10]||(t[10]=e("thead",null,[e("tr",null,[e("th",null,"Process"),e("th",null,"Arrival Time"),e("th",null,"Burst Time"),e("th")])],-1)),e("tbody",se,[(r(!0),i(L,null,N(s,(u,f)=>(r(),i("tr",{key:f},[e("td",null," P"+O(f+1),1),e("td",null,[T(e("input",{type:"number",min:"0",max:"10",required:"","onUpdate:modelValue":d=>u[0]=d},null,8,re),[[S,u[0]]])]),e("td",null,[T(e("input",{type:"number",min:"1",max:"20",required:"","onUpdate:modelValue":d=>u[1]=d},null,8,ne),[[S,u[1]]])]),e("td",oe,[s.length>1?(r(),i("div",{key:0,class:"flex items-center justify-center duration-100 border border-transparent rounded-md cursor-pointer bg-zinc-700 aspect-square w-7 group hover:border-rose-600 active:translate-y-1",onClick:d=>V(f)},[h(a($),{class:"text-rose-500",tag:"span",size:"20px"},{default:v(()=>[h(a(H))]),_:1})],8,ie)):c("",!0)])]))),128))])])]),e("button",{onClick:t[0]||(t[0]=p(()=>a(x)(w.value),["prevent"])),class:"btn",type:"submit"}," Run Algorithm ")],512),l.value?(r(),m(D,{key:0,"process-log":a(P),"queue-log":z.value,quantum:1},null,8,["process-log","queue-log"])):c("",!0),l.value?(r(),m(Q,{key:1,"process-data":s,"finished-processes":a(U)},null,8,["process-data","finished-processes"])):(r(),m(M,{key:2},{default:v(()=>[t[11]||(t[11]=e("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),e("button",{onClick:t[1]||(t[1]=p(()=>a(x)(w.value),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[11]}))])])):c("",!0)]))]),_:1}))}};export{me as default};
