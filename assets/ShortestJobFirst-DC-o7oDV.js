import{r as x,a as U,c as f,b as m,u as o,t as k,d as u,e,j as _,g as c,n as j,h as b,i as V,F as $,k as p,l as i,o as n,m as N,f as T,v as S,I as L}from"./index-CT4H9IQv.js";import{_ as J,a as M,b as O,T as D}from"./Figure-U732mrjp.js";import{_ as E,a as W}from"./ProcessDetails-B86JzO3p.js";import{_ as G}from"./Alert-nEI_Zso3.js";import{u as Q}from"./useScheduler-DOxtjO7t.js";const Z={class:"mb-10 space-y-4"},H={class:"mb-10 space-y-4"},K={class:"flex items-end gap-4"},X={class:"flex flex-wrap justify-end w-full gap-2"},Y=["disabled"],ee={class:"overflow-x-scroll"},se={class:"highlight-first-column"},te=["onUpdate:modelValue"],re=["onUpdate:modelValue"],oe={class:"w-20 mx-auto text-center"},ie=["onClick"],C=6,ce={__name:"ShortestJobFirst",setup(ne){const g=x(null),t=U([[0,4],[0,6],[0,4],[0,5]]),l=x(!1),F=f(()=>{let r=1;return t.slice().map(s=>[r++,...s,s[1]])}),v=f(()=>({runtimeProcesses:F,form:g,hasAlgorithmBeenRan:l,sortFn:(s,a)=>s[2]-a[2]})),{runAlgorithm:y,resetAlgorithmResults:w,queueLog:R,processLog:q,finishedProcesses:A}=Q(),z=f(()=>{const r=Object.groupBy(R,s=>s[0]);return Object.values(r)}),I=()=>{w(l);const s=[t[t.length-1][0]+1,Math.round(Math.random()*10)];t.push(s)},B=r=>{w(l),t.splice(r,1)},P=()=>{t.forEach(r=>{r[0]=0})};return(r,s)=>(n(),m(O,null,{[o(k).howItWorks.id]:u(()=>[e("div",Z,[s[3]||(s[3]=e("p",null,[e("span",{class:"text-main"},"Shortest Job First (SJF) Scheduling"),i(" is an algorithm used by systems to schedule the order by which processes are ran by the CPU. As the name suggests, the processes which require the shortest amount of time to complete (lowest burst time) are the ones which will be ran first. ")],-1)),p(G,{"alert-style":"warning"},{default:u(()=>s[2]||(s[2]=[e("p",null,[i(" This is a non-preemptive version of this algorithm, meaning that processes are not interrupted until they are completed, similar to how the first come first serve (FCFS) algorithm works. The latter is known as "),e("span",{class:"text-main"},"Shortest Remaining Time First (SRTF)"),i(" where a running process can be interrupted if a shorter one arrives. ")],-1)])),_:1,__:[2]}),s[4]||(s[4]=e("p",null,[i(" This algorithm is considered to be one of the best in terms of waiting time, however it requires knowledge of each process's burst time in advanced; this isn't always possible in real-world systems. This algorithm may also cause "),e("span",{class:"text-main"},"starvation:"),i(" longer processes may never get picked if shorter ones keep arriving. ")],-1)),s[5]||(s[5]=e("p",null,[i(" Regardless of the drawbacks, this algorithm reduces the average waiting time better than the "),e("span",{class:"text-main"},"First Come First Serve (FCFS)"),i(" algorithm in many cases, making it a simple and useful way of scheduling processes in a system. ")],-1)),s[6]||(s[6]=e("h1",{class:"mb-4 text-xl font-semibold"}," Understanding the Process ",-1)),s[7]||(s[7]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),s[8]||(s[8]=e("ol",{class:"grid grid-cols-1 space-y-4 gap-x-4"},[e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 1: Gather process info "),e("p",null," Each process needs to have an arrival time (when the process enters the ready queue), a burst time (how long the process needs). No additional information, such as a priority, is needed. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 2: Track the current time "),e("p",null," Initialize the system clock (usually starting at 0). This value will increase in small steps, or 1ms for our case, to simulate real-time execution of the processes. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 3: Check for new arrivals "),e("p",null," At each time step, check if any new processes have arrived (i.e., their arrival time matches the current time). Add those to the ready queue. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 4: Choose the shortest job from the queue "),e("p",null," If the CPU is idle and there are processes in the ready queue, select the one with the lowest burst time and begin processing it. If there are multiple processes with the same burst time, then the one which arrives first will be picked. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 5: Run the process for 1ms (or 1 unit) "),e("p",null," Run the process for 1ms, then repeat step 3 to add any processes that may have arrived to the ready queue. This is to ensure that the queue is up to date. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 6: Run the process until completed "),e("p",null," Repeat step 5 until the entire process is completed. Once completed, the CPU is idle once again, ready for its next process. ")]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 7: Record completion time and update logs "),e("div",null,[i(" After a process finishes, record its completion time. From this, you can calculate: "),e("ul",{class:"list-disc list-inside"},[e("li",null,"Turnaround Time = Completion Time - Arrival Time"),e("li",null,"Waiting Time = Turnaround Time - Burst Time")])])]),e("li",{class:"p-4 border rounded-md border-zinc-700"},[e("span",{class:"font-medium text-main"}," Step 8: Repeat step 3 to step 8 until all processes are finished "),e("p",null," Repeat all the steps stated for each process until the CPU is idle, and the ready queue is empty. For additional metrics, such as the waiting time and turnaround time, make sure to record the finish time of each process. ")])],-1)),p(M,{src:"/algorithms/cpu-scheduling/sjf/shortest-job-first.svg",caption:"Shortest Job First Scheduling Algorithm"})])]),[o(k).visualizer.id]:u(()=>[e("div",H,[s[11]||(s[11]=e("h1",{class:"mb-4 text-xl font-semibold"}," Step By Step Illustration ",-1)),s[12]||(s[12]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),e("form",{ref_key:"form",ref:g,class:"w-full space-y-4 gap-x-4"},[e("div",K,[e("div",X,[e("button",{class:"btn",type:"button",onClick:c(P,["prevent"])}," Set All Arrival Times to Zero "),e("button",{class:j(["btn",{disabled:t.length===C}]),type:"button",onClick:c(I,["prevent"]),disabled:t.length===C}," Add Row ",10,Y)])]),e("div",ee,[e("table",null,[s[9]||(s[9]=e("thead",null,[e("tr",null,[e("th",null,"Process"),e("th",null,"Arrival Time"),e("th",null,"Burst Time"),e("th")])],-1)),e("tbody",se,[(n(!0),b($,null,V(t,(a,h)=>(n(),b("tr",{key:h},[e("td",null," P"+N(h+1),1),e("td",null,[T(e("input",{type:"number",min:"0",max:"10",required:"","onUpdate:modelValue":d=>a[0]=d},null,8,te),[[S,a[0]]])]),e("td",null,[T(e("input",{type:"number",min:"1",max:"20",required:"","onUpdate:modelValue":d=>a[1]=d},null,8,re),[[S,a[1]]])]),e("td",oe,[t.length>1?(n(),b("div",{key:0,class:"flex items-center justify-center duration-100 border border-transparent rounded-md cursor-pointer bg-zinc-700 aspect-square w-7 group hover:border-rose-600 active:translate-y-1",onClick:d=>B(h)},[p(o(L),{class:"text-rose-500",tag:"span",size:"20px"},{default:u(()=>[p(o(D))]),_:1})],8,ie)):_("",!0)])]))),128))])])]),e("button",{onClick:s[0]||(s[0]=c(()=>o(y)(v.value),["prevent"])),class:"btn",type:"submit"}," Run Algorithm ")],512),l.value?(n(),m(E,{key:0,"process-log":o(q),"queue-log":z.value,quantum:1},null,8,["process-log","queue-log"])):_("",!0),l.value?(n(),m(W,{key:1,"process-data":t,"finished-processes":o(A)},null,8,["process-data","finished-processes"])):(n(),m(J,{key:2},{default:u(()=>[s[10]||(s[10]=e("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),e("button",{onClick:s[1]||(s[1]=c(()=>o(y)(v.value),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[10]}))])]),_:2},1024))}};export{ce as default};
