import{k as h,D as C,E as $,f as c,u as S,G as q,w as p,a as e,c as v,s as w,v as A,J as D,j as M,F,z as R,e as l,A as s,o as r,y as B}from"./index-BlRSe9Fv.js";import{_ as E,a,b as I}from"./EmptySpace-BAyMinpV.js";import{_ as U}from"./TrashButton-BRhWPkUr.js";import{_ as H,r as L}from"./SeekTimeGraph-DXa5Ei9g.js";import{_ as j}from"./Alert-IkDZ_r6i.js";const z={class:"mb-10 space-y-4"},O={class:"mb-10 space-y-4"},G={class:"flex flex-wrap items-end gap-4"},J={class:"flex flex-col gap-2"},P={class:"flex flex-col flex-1 gap-2"},Q=["disabled"],W=["onUpdate:modelValue"],K={class:"w-20 mx-auto text-center"},X={key:0},b=199,T=0,it={__name:"CScan",setup(Y){const g=h(null),i=C([98,183,37,122,14,124,65,67]),d=h(53),u=h("left"),m=C({orderedRequests:null,totalSeekTime:null}),f=h(!1);$([i,d,u],()=>{f.value=!1});const N=()=>{const o=Math.round(Math.random()*b);i.push(o)},V=o=>{i.splice(o,1)},y=()=>{if(!g.value.checkValidity())return g.value.reportValidity();const{orderedRequests:t,totalSeekTime:n}=L(d.value,i.slice(),"cScan",u.value);m.orderedRequests=t,m.totalSeekTime=n,f.value=!0};return(o,t)=>(r(),c(I,null,{[S(q).howItWorks.id]:p(()=>[e("div",z,[e("p",null,[t[5]||(t[5]=s(" The ")),t[6]||(t[6]=e("span",{class:"text-main"},"C-SCAN (circular SCAN)",-1)),t[7]||(t[7]=s(" algorithm is a variant of the ")),e("span",{class:"cursor-pointer text-main",onClick:t[0]||(t[0]=n=>o.$router.push("/disk-scheduling/scan"))},"SCAN"),t[8]||(t[8]=s(" algorithm, used to minimize the ")),t[9]||(t[9]=e("span",{class:"text-main"},"seek time",-1)),t[10]||(t[10]=s(" when responding to incoming disk requests. It works similarly to SCAN, however, instead of scanning back and forth, it only scans in one direction. "))]),e("p",null,[t[11]||(t[11]=s(" This is a disk scheduling algorithm, which requires some basic knowledge about a hard disk. To learn more about disk architecture, see the ")),e("span",{class:"cursor-pointer text-main",onClick:t[1]||(t[1]=n=>o.$router.push("/disk-scheduling/first-come-first-serve"))},"First Come First Serve (FCFS)"),t[12]||(t[12]=s(" algorithm. "))]),t[14]||(t[14]=e("h2",{class:"mt-10 text-xl font-semibold"}," How the Algorithm Works ",-1)),t[15]||(t[15]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),t[16]||(t[16]=e("p",null,[s(" Just like the SCAN algorithm, the C-SCAN variant goes towards the "),e("span",{class:"text-main"},"head direction"),s(" (either left or right), then jumps to the opposite end of the disk while ignoring any requests during the jump, and finally continues in the same direction to respond to any pending requests. ")],-1)),t[17]||(t[17]=e("p",null," To illustrate this, we need a set of disk requests, and a current head position: ",-1)),l(a,{src:"/algorithms/disk-scheduling/c-scan/disk-requests.svg",caption:"A Set of Disk Requests",class:"max-w-lg"}),t[18]||(t[18]=e("p",null," Then, lets order the requests from smallest to largest, including the first and the last track of the disk (0 and 199): ",-1)),l(a,{src:"/algorithms/disk-scheduling/c-scan/ordered-disk-requests.svg",caption:"Disk Requests Sorted in Ascending Order",class:"max-w-xl"}),t[19]||(t[19]=e("p",null," Now, C-SCAN assumes that the requests are all put inside of a circle (hence the name), so to understand how it works, we need to connect the first and last track together and form a circular queue of disk requests: ",-1)),l(a,{src:"/algorithms/disk-scheduling/c-scan/circular-disk-requests.svg",caption:"The Left-Most and Right-Most Tracks Connected Together",class:"max-w-md"}),t[20]||(t[20]=e("p",null,[s(" The "),e("span",{class:"text-main"},"head direction"),s(" determines whether the C-SCAN algorithm goes towards the left or the right. ")],-1)),t[21]||(t[21]=e("p",null," Assuming a left head direction, the algorithm starts from the current head position and moves towards the left, responding to any pending requests. If you look carefully, you'll notice how there's a huge gap from the first track and the last track (0 - 199): ",-1)),l(a,{src:"/algorithms/disk-scheduling/c-scan/c-scan-left.svg",caption:"C-SCAN Algorithm with a Left Head Direction",class:"max-w-xl"}),l(j,{"alert-style":"note"},{default:p(()=>t[13]||(t[13]=[e("p",null," The jump from 0 to 199 is important because in reality, the tracks of the disk are not arranged in a circular manner, so the disk head cannot go from 199 to 0 in 1 unit. It will actually have to travel back to the opposite end before servicing any remaining requests. ",-1)])),_:1,__:[13]}),t[22]||(t[22]=e("p",null," Similarly, if the head direction is right, then the C-SCAN algorithm will travel right and service any requests along the way: ",-1)),l(a,{src:"/algorithms/disk-scheduling/c-scan/c-scan-right.svg",caption:"C-SCAN Algorithm with a Right Head Direction",class:"max-w-xl"}),t[23]||(t[23]=e("p",null,[s(" Now, using the final order of the requests, a "),e("span",{class:"text-main"},"seek-time graph"),s(" can be plotted. The following graph illustrates the seek-time graph for the points shown earlier, with a left head direction: ")],-1)),l(a,{src:"/algorithms/disk-scheduling/c-scan/c-scan-seek-time-graph.svg",caption:"The Seek Time Graph for the C-LOOK Algorithm"})])]),[S(q).visualizer.id]:p(()=>[e("div",O,[t[29]||(t[29]=e("h1",{class:"mb-4 text-xl font-semibold"}," Step By Step Illustration ",-1)),t[30]||(t[30]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),e("form",{class:"space-y-4",ref_key:"form",ref:g},[e("div",G,[e("div",J,[t[24]||(t[24]=e("label",{class:"font-medium"},"Current Head Position:",-1)),w(e("input",{type:"number",class:"field",min:T,max:b,"onUpdate:modelValue":t[2]||(t[2]=n=>d.value=n)},null,512),[[A,d.value]])]),e("div",P,[t[26]||(t[26]=e("label",{class:"font-medium"},"Head Direction:",-1)),w(e("select",{class:"field","onUpdate:modelValue":t[3]||(t[3]=n=>u.value=n)},t[25]||(t[25]=[e("option",{value:"left"},"Left",-1),e("option",{value:"right"},"Right",-1)]),512),[[D,u.value]])]),e("button",{type:"button",class:"btn",disabled:i.length===15,onClick:N},"Add Row",8,Q)]),e("table",null,[t[27]||(t[27]=e("thead",null,[e("tr",null,[e("th",null,"Disk Requests"),e("th")])],-1)),e("tbody",null,[(r(!0),v(F,null,M(i,(n,k)=>(r(),v("tr",null,[e("td",null,[w(e("input",{type:"number","onUpdate:modelValue":x=>i[k]=x,min:T,max:b},null,8,W),[[A,i[k]]])]),e("td",K,[i.length>1?(r(),c(U,{key:0,onClick:x=>V(k)},null,8,["onClick"])):B("",!0)])]))),256))])]),e("button",{type:"submit",class:"btn",onClick:R(y,["prevent"])},"Run Algorithm")],512),t[31]||(t[31]=e("h2",{class:"mt-10 text-xl font-semibold"}," Results ",-1)),t[32]||(t[32]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),f.value?(r(),v("div",X,[l(H,{"ordered-requests":m.orderedRequests,"total-seek-time":m.totalSeekTime},null,8,["ordered-requests","total-seek-time"])])):(r(),c(E,{key:1},{default:p(()=>[t[28]||(t[28]=e("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),e("button",{onClick:t[4]||(t[4]=R(()=>y(),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[28]}))])]),_:2},1024))}};export{it as default};
