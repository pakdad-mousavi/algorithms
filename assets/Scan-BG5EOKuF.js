import{k as h,A as S,B as F,f as c,u as A,D as R,w as k,a as t,c as v,s as b,v as q,L as D,j as $,F as B,z as C,e as n,E as l,o as a,y as I}from"./index-CpffD29e.js";import{_ as M,a as r,b as E,c as U}from"./TrashButton-D3GXsOfM.js";import{_ as L,r as H}from"./SeekTimeGraph-BlAnPgRg.js";const z={class:"mb-10 space-y-4"},P={class:"mb-10 space-y-4"},G={class:"flex flex-wrap items-end gap-4"},Q={class:"flex flex-col gap-2"},W={class:"flex flex-col flex-1 gap-2"},j=["disabled"],X=["onUpdate:modelValue"],J={class:"w-20 mx-auto text-center"},K={key:0},w=199,T=0,ee={__name:"Scan",setup(O){const g=h(null),s=S([98,183,37,122,14,124,65,67]),d=h(53),u=h("left"),m=S({orderedRequests:null,totalSeekTime:null}),p=h(!1);F([s,d,u],()=>{p.value=!1});const N=()=>{const i=Math.round(Math.random()*w);s.push(i)},V=i=>{s.splice(i,1)},x=()=>{if(!g.value.checkValidity())return g.value.reportValidity();const{orderedRequests:e,totalSeekTime:o}=H(d.value,s.slice(),"scan",u.value);m.orderedRequests=e,m.totalSeekTime=o,p.value=!0};return(i,e)=>(a(),c(E,null,{[A(R).howItWorks.id]:k(()=>[t("div",z,[e[6]||(e[6]=t("p",null,[l(" The "),t("span",{class:"text-main"},"SCAN"),l(" algorithm is a disk scheduling algorithm used to minimize the "),t("span",{class:"text-main"},"seek time"),l(" when responding to incoming disk requests, while avoiding starvation. It works by moving from one end of the disk to the other, and then back, responding to all requests on the way. ")],-1)),t("p",null,[e[4]||(e[4]=l(" This is a disk scheduling algorithm, which requires some basic knowledge about a hard disk. To learn more about disk architecture, see the ")),t("span",{class:"cursor-pointer text-main",onClick:e[0]||(e[0]=o=>i.$router.push("/disk-scheduling/first-come-first-serve"))},"First Come First Serve (FCFS)"),e[5]||(e[5]=l(" algorithm. "))]),e[7]||(e[7]=t("h2",{class:"mt-10 text-xl font-semibold"}," How the Algorithm Works ",-1)),e[8]||(e[8]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[9]||(e[9]=t("p",null," The SCAN algorithm works like an elevator. It moves from the current head position to the left most end (or right most end depending on the head direction), addressing any requests along the way. It then reverses and travels to the opposite end, to address any requests left. ",-1)),e[10]||(e[10]=t("p",null," To put this into perspective, consider the following disk requests plotted on a seek time graph ordered from smallest to largest (without any specific vertical order): ",-1)),n(r,{src:"/algorithms/disk-scheduling/scan/disk-requests.svg",class:"max-w-2xl",caption:"Disk Requests Plotted on a Graph"}),e[11]||(e[11]=t("p",null,[l(" The SCAN algorithm travels either to the right most end or the left most end, and fulfills any pending requests along the way. The direction in which it initially travels in is determined by the "),t("span",{class:"text-main"},"head direction"),l(": ")],-1)),n(r,{src:"/algorithms/disk-scheduling/scan/direction-of-head.svg",class:"max-w-2xl",caption:"Direction of Head Determines Scan Direction"}),e[12]||(e[12]=t("p",null," The following diagram illustrates how the SCAN algorithm would work on the following requests, given the direction of the head was left: ",-1)),n(r,{src:"/algorithms/disk-scheduling/scan/scan-left-to-right.svg",class:"max-w-3xl",caption:"SCAN Algorithm From Left to Right"}),e[13]||(e[13]=t("p",null," If the direction of the head was right, then the SCAN algorithm would first travel to the right most end of the disk, and then back: ",-1)),n(r,{src:"/algorithms/disk-scheduling/scan/scan-right-to-left.svg",class:"max-w-3xl",caption:"SCAN Algorithm From Right to Left"}),e[14]||(e[14]=t("p",null,[l(" Finally, to calculate the total seek time, a "),t("span",{class:"text-main"},"seek time graph"),l(" can be used. The following diagram illustrates the SCAN algorithm's seek time graph, given the following requests and a left head direction: ")],-1)),n(r,{src:"/algorithms/disk-scheduling/scan/scan-seek-time-graph.svg",caption:"SCAN Algorithm Seek Time Graph"})])]),[A(R).visualizer.id]:k(()=>[t("div",P,[e[20]||(e[20]=t("h1",{class:"mb-4 text-xl font-semibold"}," Step By Step Illustration ",-1)),e[21]||(e[21]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),t("form",{class:"space-y-4",ref_key:"form",ref:g},[t("div",G,[t("div",Q,[e[15]||(e[15]=t("label",{class:"font-medium"},"Current Head Position:",-1)),b(t("input",{type:"number",class:"field",min:T,max:w,"onUpdate:modelValue":e[1]||(e[1]=o=>d.value=o)},null,512),[[q,d.value]])]),t("div",W,[e[17]||(e[17]=t("label",{class:"font-medium"},"Head Direction:",-1)),b(t("select",{class:"field","onUpdate:modelValue":e[2]||(e[2]=o=>u.value=o)},e[16]||(e[16]=[t("option",{value:"left"},"Left",-1),t("option",{value:"right"},"Right",-1)]),512),[[D,u.value]])]),t("button",{type:"button",class:"btn",disabled:s.length===15,onClick:N},"Add Row",8,j)]),t("table",null,[e[18]||(e[18]=t("thead",null,[t("tr",null,[t("th",null,"Disk Requests"),t("th")])],-1)),t("tbody",null,[(a(!0),v(B,null,$(s,(o,f)=>(a(),v("tr",null,[t("td",null,[b(t("input",{type:"number","onUpdate:modelValue":y=>s[f]=y,min:T,max:w},null,8,X),[[q,s[f]]])]),t("td",J,[s.length>1?(a(),c(U,{key:0,onClick:y=>V(f)},null,8,["onClick"])):I("",!0)])]))),256))])]),t("button",{type:"submit",class:"btn",onClick:C(x,["prevent"])},"Run Algorithm")],512),e[22]||(e[22]=t("h2",{class:"mt-10 text-xl font-semibold"}," Results ",-1)),e[23]||(e[23]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),p.value?(a(),v("div",K,[n(L,{"ordered-requests":m.orderedRequests,"total-seek-time":m.totalSeekTime},null,8,["ordered-requests","total-seek-time"])])):(a(),c(M,{key:1},{default:k(()=>[e[19]||(e[19]=t("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),t("button",{onClick:e[3]||(e[3]=C(()=>x(),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[19]}))])]),_:2},1024))}};export{ee as default};
