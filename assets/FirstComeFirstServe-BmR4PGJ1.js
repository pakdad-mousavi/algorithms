import{r as y,a as V,c as g,b as a,u as r,t as w,d as f,e,j as C,g as h,h as k,i as L,F as I,k as m,l as s,o,m as O,f as A,v as T}from"./index-D9u_6dsU.js";import{_ as Q,a as d,b as N,c as j}from"./TrashButton-DC0a_cT1.js";import{_ as D,a as M}from"./ProcessDetails-D7NRzHgX.js";import{u as W}from"./useScheduler-V9qAKa4e.js";const z={class:"mb-10 space-y-4"},H={class:"space-y-4"},Z={class:"flex items-end gap-4"},G={class:"flex flex-wrap justify-end w-full gap-2"},J=["disabled"],K={class:"overflow-x-scroll"},X={class:"highlight-first-column"},Y=["onUpdate:modelValue"],_=["onUpdate:modelValue"],ee={class:"w-20 mx-auto text-center"},te=6,ie={__name:"FirstComeFirstServe",setup(se){const b=y(null),l=V([[0,4],[0,6],[0,4],[0,5]]),i=y(!1),q=g(()=>{let n=1;return l.slice().map(t=>[n++,...t,t[1]])}),v=g(()=>({runtimeProcesses:q,form:b,hasAlgorithmBeenRan:i,sortFn:null})),{runAlgorithm:x,resetAlgorithmResults:P,queueLog:U,processLog:F,finishedProcesses:S}=W(),B=g(()=>{const n=Object.groupBy(U,t=>t[0]);return Object.values(n)}),E=()=>{P(i);const t=[l[l.length-1][0]+1,Math.round(Math.random()*10)];l.push(t)},$=n=>{P(i),l.splice(n,1)},R=()=>{l.forEach(n=>{n[0]=0})};return(n,t)=>(o(),a(N,null,{[r(w).howItWorks.id]:f(()=>[e("div",z,[t[7]||(t[7]=e("p",null,[s(" The "),e("span",{class:"text-main"},"first come first serve"),s(" is one of the simplest CPU scheduling algorithms, providing a straightforward way for the CPU to handle incoming processes. ")],-1)),e("p",null,[t[3]||(t[3]=s(" As the name suggests, processes that arrive and enter the ready ")),t[4]||(t[4]=e("span",{class:"text-main"},"queue",-1)),t[5]||(t[5]=s(" first, will be processed first. To learn more about how a queue works, see the ")),e("span",{class:"cursor-pointer text-main",onClick:t[0]||(t[0]=u=>n.$router.push("/cpu-scheduling/round-robin"))},"round robin"),t[6]||(t[6]=s(" algorithm. "))]),t[8]||(t[8]=e("p",null," However, unlike the round robin algorithm, the CPU will be allocated entirely to that process until it is fully executed and completed. Only then will the CPU move on to the next process in the ready queue. ",-1)),t[9]||(t[9]=e("h2",{class:"mt-10 text-xl font-semibold"}," How the Algorithm Works ",-1)),t[10]||(t[10]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),t[11]||(t[11]=e("p",null,[s(" Like the round robin algorithm, FCFS relies on a queue to keep track of which processes to process first. The only difference is that FCFS does not have a "),e("span",{class:"text-main"},"time slice/quantum"),s(", so it lets the process execute as long as it needs to. ")],-1)),t[12]||(t[12]=e("p",null," Consider the following processes: ",-1)),t[13]||(t[13]=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Process ID:"),e("th",null,"Arrival Time:"),e("th",null,"Burst Time:")])]),e("tbody",null,[e("tr",null,[e("td",null,"P1"),e("td",null,"0"),e("td",null,"4")]),e("tr",null,[e("td",null,"P2"),e("td",null,"1"),e("td",null,"2")]),e("tr",null,[e("td",null,"P3"),e("td",null,"2"),e("td",null,"3")])])],-1)),t[14]||(t[14]=e("p",null,[s(" The "),e("span",{class:"text-main"},"arrival time"),s(" column tells us at what time a process enters the queue. The "),e("span",{class:"text-main"},"burst time"),s(" tells us the total time that process needs to be in the CPU before it is completed. ")],-1)),t[15]||(t[15]=e("p",null," To run the FCFS algorithm, a queue and CPU are needed: ",-1)),m(d,{src:"/algorithms/cpu-scheduling/fcfs/queue-and-cpu.svg",class:"max-w-xl",caption:"An Example Empty Queue With 3 Slots, and an Empty CPU"}),t[16]||(t[16]=e("p",null," Our clock starts at 0ms. At 0ms, process 1 (P1) arrives and enters the queue. Since the CPU is idle, the algorithm will pick P1 for processing: ",-1)),m(d,{src:"/algorithms/cpu-scheduling/fcfs/0ms-example-state.svg",class:"max-w-xl",caption:"P1 Arrives and Enters Queue, Leaves the Queue, and Enters CPU for Processing"}),t[17]||(t[17]=e("p",null,[s(" FCFS is "),e("span",{class:"text-main"},"non-preemptive"),s(", so the CPU will not be interrupted until it has completed executing the process for the total duration of its burst time. ")],-1)),t[18]||(t[18]=e("p",null," At 1ms, P2 arrives and enters the queue: ",-1)),m(d,{src:"/algorithms/cpu-scheduling/fcfs/1ms-example-state.svg",class:"max-w-xl",caption:"P2 Arrives and Enters Queue"}),t[19]||(t[19]=e("p",null," At 2ms, P3 arrives and enters the queue (P1 is still being processed in the CPU): ",-1)),m(d,{src:"/algorithms/cpu-scheduling/fcfs/2ms-example-state.svg",class:"max-w-xl",caption:"P3 Arrives and Enters Queue"}),t[20]||(t[20]=e("p",null," At 3ms, no process arrives and the CPU is still processing P1 (P1 has a burst time of 4ms, so there is still 1ms remaining), therefore no changes occur in the queue or CPU. ",-1)),t[21]||(t[21]=e("p",null," At 4ms, P1 finishes processing and has been fully executed, therefore it no longer needs to go to the back of the queue. Once the CPU is idle, the next process is picked from the queue by the algorithm for processing: ",-1)),m(d,{src:"/algorithms/cpu-scheduling/fcfs/4ms-example-state.svg",class:"max-w-xl",caption:"P1 Finishes Processing, and P2 Begins to Run"}),t[22]||(t[22]=e("p",null,[s(" The algorithm continues to operate like this until there are no more processes remaining in the queue. Calculating additional metrics such as the "),e("span",{class:"text-main"},"turnaround time"),s(" and "),e("span",{class:"text-main"},"waiting time"),s(" use the same calculation stated in the round robin algorithm: ")],-1)),t[23]||(t[23]=e("p",{class:"italic"}," Turnaround Time = Completion Time - Arrival Time ",-1)),t[24]||(t[24]=e("p",{class:"italic"}," Waiting Time = Turnaround Time - Burst Time ",-1))])]),[r(w).visualizer.id]:f(()=>[e("div",H,[t[27]||(t[27]=e("h1",{class:"mb-4 text-xl font-semibold"}," Step by Step Illustration ",-1)),t[28]||(t[28]=e("hr",{class:"mb-4 border-neutral-800"},null,-1)),e("form",{ref_key:"form",ref:b,class:"w-full space-y-4 gap-x-4"},[e("div",Z,[e("div",G,[e("button",{class:"btn",type:"button",onClick:h(R,["prevent"])}," Set All Arrival Times to Zero "),e("button",{class:"btn",type:"button",onClick:h(E,["prevent"]),disabled:l.length===te}," Add Row ",8,J)])]),e("div",K,[e("table",null,[t[25]||(t[25]=e("thead",null,[e("tr",null,[e("th",null,"Process"),e("th",null,"Arrival Time"),e("th",null,"Burst Time"),e("th")])],-1)),e("tbody",X,[(o(!0),k(I,null,L(l,(u,c)=>(o(),k("tr",{key:c},[e("td",null," P"+O(c+1),1),e("td",null,[A(e("input",{type:"number",min:"0",max:"10",required:"","onUpdate:modelValue":p=>u[0]=p},null,8,Y),[[T,u[0]]])]),e("td",null,[A(e("input",{type:"number",min:"1",max:"20",required:"","onUpdate:modelValue":p=>u[1]=p},null,8,_),[[T,u[1]]])]),e("td",ee,[l.length>1?(o(),a(j,{key:0,onClick:p=>$(c)},null,8,["onClick"])):C("",!0)])]))),128))])])]),e("button",{onClick:t[1]||(t[1]=h(()=>r(x)(v.value),["prevent"])),class:"btn",type:"submit"}," Run Algorithm ")],512),i.value?(o(),a(D,{key:0,"process-log":r(F),"queue-log":B.value,quantum:1},null,8,["process-log","queue-log"])):C("",!0),i.value?(o(),a(M,{key:1,"process-data":l,"finished-processes":r(S)},null,8,["process-data","finished-processes"])):(o(),a(Q,{key:2},{default:f(()=>[t[26]||(t[26]=e("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),e("button",{onClick:t[2]||(t[2]=h(()=>r(x)(v.value),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[26]}))])]),_:2},1024))}};export{ie as default};
