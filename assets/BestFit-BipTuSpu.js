import{k as f,D as B,E as P,f as h,u as v,G as V,w,a as t,s as u,v as x,c as d,j as z,F as D,z as I,e as T,A as b,h as U,o as a,J as F,t as $,y as M}from"./index-C6gGSE4_.js";import{_ as N,a as S,b as L,c as _}from"./EmptySpace-BAQsNv1F.js";import{_ as E,r as j}from"./memory-management-PqEWle4S.js";import"./Alert-C2oB2L4l.js";const q={class:"mb-10 space-y-4"},H={class:"mb-10 space-y-4"},W={class:"flex flex-wrap items-end gap-4"},G={class:"flex flex-col gap-2"},J={class:"flex flex-col flex-1 gap-2"},O={class:"flex gap-2"},Q=["disabled"],X={class:"overflow-x-scroll"},Y=["onUpdate:modelValue"],Z=["onUpdate:modelValue"],ee=["value"],te=["onUpdate:modelValue"],se={class:"w-20 mx-auto text-center"},re={__name:"BestFit",setup(le){const K=U(),g=f(null),p=f(4),m=f(100),o=B([{isAllocation:!0,pid:1,size:30},{isAllocation:!0,pid:2,size:35},{isAllocation:!0,pid:3,size:20},{isAllocation:!1,pid:2},{isAllocation:!0,pid:4,size:15}]),y=B({isSuccessful:!1,memoryLog:[]}),c=f(!1);P([o,m],()=>{c.value=!1});const C=n=>{o.splice(n,1)},R=()=>{const n=p.value,e=new Set(o.filter(s=>s.isAllocation).map(s=>s.pid)),l=new Set(o.filter(s=>!s.isAllocation).map(s=>s.pid)),i=[...e].filter(s=>!l.has(s));if(e.size<n){let s=null;for(let r=1;r<=n;r++)if(!e.has(r)){s=r;break}const A={isAllocation:!0,pid:s,size:10};o.push(A)}else if(i.length>0){const s=Math.floor(Math.random()*i.length),r={isAllocation:!1,pid:i[s]};o.push(r)}},k=()=>{if(!g.value.checkValidity())return g.value.reportValidity();const{isSuccessful:e,memoryLog:l}=j(o,m.value,"bestFit");y.isSuccessful=e,y.memoryLog=l,c.value=!0};return(n,e)=>(a(),h(L,null,{[v(V).howItWorks.id]:w(()=>[t("div",q,[e[7]||(e[7]=t("p",null,[b(" The "),t("span",{class:"text-main"},"Best Fit Algorithm"),b(" is another memory allocation strategy used in dynamic memory management. It's job is also to manage free space in the main memory, however, this algorithm aims to waste the least amount of space. ")],-1)),t("p",null,[e[4]||(e[4]=b(" As memory is allocated and deallocated to and from processes, the memory becomes ")),e[5]||(e[5]=t("span",{class:"text-main"},"fragmented",-1)),e[6]||(e[6]=b(". To understand how memory works and how fragmentation occurs, see the ")),t("span",{class:"cursor-pointer text-main",onClick:e[0]||(e[0]=l=>v(K).push("/memory-management/first-fit"))}," First Fit Algorithm. ")]),e[8]||(e[8]=t("h2",{class:"mt-10 text-xl font-semibold"}," How It Works ",-1)),e[9]||(e[9]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[10]||(e[10]=t("p",null," The best fit algorithm scans all free blocks of memory. From those blocks that are large enough for the process, it chooses the one with the smallest possible size. This minimizes wasted space by ensuring that the leftover memory in the chosen block is as small as possible. If no suitable block is found, the allocation fails. ",-1)),e[11]||(e[11]=t("p",null," Lets say we have allocated 50KB to process 1, then 80KB to process 2, and finally 10KB to process 3. Between each process, there's 20KB, 50KB, and 40KB worth of free space respectively: ",-1)),T(S,{src:"/algorithms/memory-management/best-fit/example-allocation.svg",class:"max-w-2xl",caption:"Example Memory Allocation"}),e[12]||(e[12]=t("p",null," The best fit algorithm would look amongst all the free blocks of memory that are large enough for the process (50KB and 40KB), and then it will choose the smallest block amongst those. This allows for the least amount of space to be wasted, like so: ",-1)),T(S,{src:"/algorithms/memory-management/best-fit/best-fit-algorithm.svg",class:"max-w-2xl",caption:"How the Best Fit Algorithm Chooses a Memory Block"})])]),[v(V).visualizer.id]:w(()=>[t("div",H,[e[18]||(e[18]=t("h2",{class:"text-xl font-semibold"}," Step by Step Illustration ",-1)),e[19]||(e[19]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),t("form",{class:"space-y-4",ref_key:"form",ref:g},[t("div",W,[t("div",G,[e[13]||(e[13]=t("label",{class:"font-medium"},"Number of Processes:",-1)),u(t("input",{type:"number",class:"w-full field sm:w-60",min:"1",max:"6",required:"","onUpdate:modelValue":e[1]||(e[1]=l=>p.value=l)},null,512),[[x,p.value]])]),t("div",J,[e[14]||(e[14]=t("label",{class:"font-medium"},"Total Memory Size (KB):",-1)),u(t("input",{type:"number",class:"w-full field sm:w-60",min:"10",max:"150",required:"","onUpdate:modelValue":e[2]||(e[2]=l=>m.value=l)},null,512),[[x,m.value]])]),t("div",O,[t("button",{class:"btn",type:"button",onClick:e[3]||(e[3]=l=>R()),disabled:o.length===12}," Add Row ",8,Q)])]),t("div",X,[t("table",null,[e[16]||(e[16]=t("thead",null,[t("tr",null,[t("th",null,"Action Type"),t("th",null,"Process ID"),t("th",null,"Size (KB)"),t("th")])],-1)),t("tbody",null,[(a(!0),d(D,null,z(o,(l,i)=>(a(),d("tr",{key:i},[t("td",null,[u(t("select",{"onUpdate:modelValue":s=>l.isAllocation=s},e[15]||(e[15]=[t("option",{value:!0},"Allocation",-1),t("option",{value:!1},"Deallocation",-1)]),8,Y),[[F,l.isAllocation]])]),t("td",null,[u(t("select",{"onUpdate:modelValue":s=>l.pid=s},[(a(!0),d(D,null,z(p.value,s=>(a(),d("option",{value:s},$(s),9,ee))),256))],8,Z),[[F,l.pid]])]),t("td",null,[l.isAllocation?u((a(),d("input",{key:0,min:"10",type:"number","onUpdate:modelValue":s=>l.size=s},null,8,te)),[[x,l.size]]):M("",!0)]),t("td",se,[o.length>1?(a(),h(_,{key:0,onClick:s=>C(i)},null,8,["onClick"])):M("",!0)])]))),128))])])]),t("button",{type:"submit",class:"btn",onClick:I(k,["prevent"])},"Run Algorithm")],512),e[20]||(e[20]=t("h2",{class:"mt-10 text-xl font-semibold"}," Results ",-1)),e[21]||(e[21]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),c.value?(a(),h(E,{key:0,"has-algorithm-been-ran":c.value,"total-memory":m.value,"alg-result":y,actions:o},null,8,["has-algorithm-been-ran","total-memory","alg-result","actions"])):(a(),h(N,{key:1},{default:w(()=>[e[17]||(e[17]=t("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),t("button",{onClick:I(k,["prevent"]),class:"btn"}," Run Algorithm ")]),_:1}))])]),_:2},1024))}};export{re as default};
