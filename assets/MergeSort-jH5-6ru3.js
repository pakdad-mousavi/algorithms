import{l as V,c as n,o as s,a as t,F as x,j as y,t as C,H,y as q,B as I,k as B,D as W,E as X,f as F,u as E,G as O,w as P,s as J,J as Q,z as Y,e as h,A as l,v as Z}from"./index-C6gGSE4_.js";import{_,a as v,b as K,c as ee}from"./EmptySpace-BAQsNv1F.js";import{_ as te}from"./Alert-C2oB2L4l.js";import{m as se}from"./sorting-numbers-92u9tv0B.js";const re={class:"space-y-40"},oe={class:"overflow-x-auto"},le={class:"space-y-10"},ne={class:"flex mx-auto overflow-hidden border rounded-md max-w-max border-zinc-700"},ie={key:0,class:"flex mx-auto overflow-hidden border rounded-md max-w-max border-zinc-700"},ae={class:"overflow-x-auto"},ue={class:"space-y-10"},de={key:0,class:"flex mx-auto overflow-hidden border rounded-md max-w-max border-zinc-700"},me={class:"flex w-full sm:justify-center gap-x-4"},ge={class:"flex mx-auto overflow-hidden border rounded-md max-w-max border-zinc-700"},pe={__name:"MergeSort",props:{log:{type:Array,required:!0},isAscending:{type:Boolean,required:!0},initial:{type:Array,required:!0}},setup(j){const f=j,g=V(()=>{const p=(u,r)=>f.isAscending?u-r:r-u;return f.initial.slice().sort(p)}),k=(p,u,r,o=!1)=>{const e=Math.max(...f.log.map(i=>i[p])),a={},b=(i,c,d)=>{a[c]||(a[c]={}),a[c][d]=i},T=(i,c)=>i.every(d=>c.includes(d)),$=(i,c,d)=>{var N,R,L,U;const m=o?c-1:c+1;if(m<1||m>e)return;a[m]||(a[m]={}),(N=a[m])[R=d*2]??(N[R]=null),(L=a[m])[U=d*2+1]??(L[U]=null);const w=f.log.find(D=>D[p]===m&&(T(D[u],i)||T(D[r],i)));w&&(b(w[u],m,d*2),b(w[r],m,d*2+1),$(w[u],m,d*2),$(w[r],m,d*2+1))},S=o?f.log.find(i=>i[p]===e):f.log.find(i=>i[p]===1);if(S){const i=o?e:1;b(S[u],i,0),b(S[r],i,1),$(S[u],i,0),$(S[r],i,1)}return Array.from({length:e},(i,c)=>{const d=c+1,m=o?e-d+1:d,w=Array(2**m).fill(null);if(a[d])for(const[N,R]of Object.entries(a[d]))w[N]=R;return{depth:m,slots:w}})},M=V(()=>k("splitDepth","left","right")),z=V(()=>k("mergeDepth","mergedLeft","mergedRight",!0)),A=p=>Array.isArray(p)&&p.length===1;return(p,u)=>(s(),n("div",re,[t("div",oe,[u[0]||(u[0]=t("h2",{class:"mb-4 text-lg font-bold text-center underline"},"Split Tree",-1)),t("div",le,[t("div",ne,[(s(!0),n(x,null,y(j.initial,(r,o)=>(s(),n("div",{key:o,class:"flex items-center justify-center border-r size-14 border-zinc-700 last:border-r-0"},C(r),1))),128))]),(s(!0),n(x,null,y(M.value,r=>(s(),n("div",{key:"s"+r.depth,class:"flex w-full sm:justify-center gap-x-4"},[(s(!0),n(x,null,y(r.slots,(o,e)=>(s(),n("div",{key:e,style:H(`width: ${100/2**r.depth}%`)},[o?(s(),n("div",ie,[(s(!0),n(x,null,y(o,(a,b)=>(s(),n("div",{key:b,class:I(["flex items-center justify-center border-r size-14 border-zinc-700 last:border-r-0",{"bg-zinc-800 text-white":A(o)}])},C(a),3))),128))])):q("",!0)],4))),128))]))),128))])]),t("div",ae,[u[1]||(u[1]=t("h2",{class:"mb-4 text-lg font-bold text-center underline"},"Merge Tree",-1)),t("div",ue,[(s(!0),n(x,null,y(z.value,r=>(s(),n("div",{key:"m"+r.depth,class:"flex w-full sm:justify-center gap-x-4"},[(s(!0),n(x,null,y(r.slots,(o,e)=>(s(),n("div",{key:e,style:H(`width: ${100/2**r.depth}%`)},[o?(s(),n("div",de,[(s(!0),n(x,null,y(o,(a,b)=>(s(),n("div",{key:b,class:"flex items-center justify-center border-r size-14 border-zinc-700 last:border-r-0"},C(a),1))),128))])):q("",!0)],4))),128))]))),128)),t("div",me,[t("div",ge,[(s(!0),n(x,null,y(g.value,(r,o)=>(s(),n("div",{key:o,class:"flex items-center justify-center text-white border-r size-14 border-zinc-700 last:border-r-0 bg-zinc-800"},C(r),1))),128))])])])])]))}},be={class:"mb-10 space-y-4"},he={class:"mb-10 space-y-4"},fe={class:"flex items-end gap-4"},ce={class:"flex flex-col flex-1 gap-2"},ve=["disabled"],xe=["onUpdate:modelValue"],ye={class:"w-20 mx-auto text-center"},we={key:0},G=100,ze={__name:"MergeSort",setup(j){const f=B(null),g=W([5,1,4,2,8,6,9,7]),k=B("ascending"),M=V(()=>k.value==="ascending"),z=W({log:null}),A=B(!1);X([g,k],()=>{A.value=!1});const p=()=>{const o=Math.round(Math.random()*G);g.push(o)},u=o=>{g.splice(o,1)},r=()=>{if(!f.value.checkValidity())return f.value.reportValidity();const e=se(g,M.value);z.log=e,A.value=!0};return(o,e)=>(s(),F(K,null,{[E(O).howItWorks.id]:P(()=>[t("div",be,[e[6]||(e[6]=t("p",null,[t("span",{class:"text-main"},"Merge Sort"),l(" is a "),t("span",{class:"text-main"},"divide and conquer"),l(" sorting algorithm used to sort a series of numbers in order, either from smallest to largest (ascending order), or from largest to smallest (descending order). ")],-1)),t("p",null,[e[3]||(e[3]=l(" To learn more about how the sorting problem, see ")),t("span",{class:"cursor-pointer text-main",onClick:e[0]||(e[0]=a=>o.$router.push("/sorting-numbers/bubble-sort"))},"Bubble Sort"),e[4]||(e[4]=l(". "))]),e[7]||(e[7]=t("h2",{class:"mt-10 text-xl font-semibold"}," How Merge Sort Works ",-1)),e[8]||(e[8]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[9]||(e[9]=t("p",null," Consider the following list of numbers: ",-1)),h(v,{src:"/algorithms/sorting-numbers/merge-sort/unsorted-numbers.svg",class:"max-w-xs",caption:"A List of Unsorted Numbers"}),e[10]||(e[10]=t("p",null,[l(" Merge sort works by repeatedly "),t("span",{class:"text-main"},"dividing"),l(" the list of numbers into halves until it reaches a single element (which is already sorted): ")],-1)),h(v,{src:"/algorithms/sorting-numbers/merge-sort/splitting-numbers.svg",class:"max-w-xl",caption:"Splitting a List Into Halves"}),e[11]||(e[11]=t("p",null," You are then left with a series of number pairs. You may also have a singular number value if the total number of values in the list was odd: ",-1)),h(v,{src:"/algorithms/sorting-numbers/merge-sort/split-number-pairs.svg",class:"max-w-md",caption:"A Series of Number Pairs and a Singular Value"}),e[12]||(e[12]=t("p",null," Sorting the list is easy now! Each singular value can already be considered to be sorted, since it is only one value. All that's left to do is put the numbers back together in the correct order. ",-1)),e[13]||(e[13]=t("p",null,[l(" The merge sort algorithm "),t("span",{class:"text-main"},"conquers"),l(" by merging the small sorted arrays back together into bigger sorted arrays. It repeat merging until you have one fully sorted array: ")],-1)),h(v,{src:"/algorithms/sorting-numbers/merge-sort/merging-number-pairs.svg",class:"max-w-md",caption:"Merging Smaller Sorted Arrays Into a Singular Sorted Array"}),e[14]||(e[14]=t("p",null," Just like that, merge sort has successfully sorted the list, by breaking the problem down into smaller more manageable subproblems, solving those problems, and putting the result back up together. ",-1)),e[15]||(e[15]=t("h2",{class:"mt-10 text-xl font-semibold"}," Merging Two Piles Together ",-1)),e[16]||(e[16]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[17]||(e[17]=t("p",null," Now that the concept of merge sort has been explained, lets move onto the details. How does merge sort know how to correctly merge two sorted subarrays together, to form a larger sorted array? ",-1)),e[18]||(e[18]=t("p",null,[l(" First, the algorithm assigns a "),t("span",{class:"text-main"},"head"),l(" to each pile. The head will point to the first item in each pile: ")],-1)),h(v,{src:"/algorithms/sorting-numbers/merge-sort/intializing-pile-merge.svg",class:"max-w-xs",caption:"Initializing the Merge of Two Piles"}),e[19]||(e[19]=t("p",null," The algorithm then compares the two values that each of the heads point to. The lesser value is added to the new sorted pile. ",-1)),e[20]||(e[20]=t("p",null," Afterwards, the head position of the pile which had the lesser value is incremented by 1, to point to the next value inside of the pile: ",-1)),h(v,{src:"/algorithms/sorting-numbers/merge-sort/pile-merge-1.svg",class:"max-w-xs",caption:"The First Pass of Merging the Pile Together"}),e[21]||(e[21]=t("p",null," This works because the algorithm no longer needs to worry about the other values in the piles, because they are already sorted! ",-1)),e[22]||(e[22]=t("p",null," The same process is then repeated: ",-1)),h(v,{src:"/algorithms/sorting-numbers/merge-sort/pile-merge-2.svg",class:"max-w-xs",caption:"The Second Pass of Merging the Pile Together"}),e[23]||(e[23]=t("p",null," And once more: ",-1)),h(v,{src:"/algorithms/sorting-numbers/merge-sort/pile-merge-3.svg",class:"max-w-xs",caption:"The Third Pass of Merging the Pile Together"}),e[24]||(e[24]=t("p",null," Note that if the items in a pile finish, the process is stopped, and the rest of the values from the remaining pile are dumped to the end of the new pile: ",-1)),h(v,{src:"/algorithms/sorting-numbers/merge-sort/pile-merge-4.svg",class:"max-w-xs",caption:"The Final Pass of Merging the Pile Together"}),e[25]||(e[25]=t("h2",{class:"mt-10 text-xl font-semibold"}," Key Metrics ",-1)),e[26]||(e[26]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[27]||(e[27]=t("p",null,[l(" Merge sort has a "),t("span",{class:"text-main"},"time complexity"),l(" of "),t("span",{class:"text-main"},"O(n log n)"),l(' (where "n" is the total number of values being sorted). This means that it exponentially decreases the time needed to sort the array, making it an extremely efficient algorithm when it comes to sorting numbers. ')],-1)),h(te,{"alert-style":"note"},{default:P(()=>e[5]||(e[5]=[t("div",{class:"space-y-4"},[t("p",null," To put this into perspective, imagine sorting 1000 numbers. "),t("p",null,[l(" With algorithms like "),t("span",{class:"text-main"},"bubble sort"),l(", "),t("span",{class:"text-main"},"selection sort"),l(", or "),t("span",{class:"text-main"},"insertion sort"),l(", with a time complexity of "),t("span",{class:"text-main"},[l("O(n"),t("sup",null,"2"),l(")")]),l(", there would be 1,000 * 1,000 = 1,000,000 operations made, taking about 16.6 minutes (assuming that each operation takes 1 ms)! ")]),t("p",null,[l(" With merge sort, there would be 1000 * log"),t("sub",null,"2"),l("(1000) â‰ˆ 9,966 operations made, taking about just 10 seconds; a significant difference. ")])],-1)])),_:1,__:[5]})])]),[E(O).visualizer.id]:P(()=>[t("div",he,[e[32]||(e[32]=t("h1",{class:"mb-4 text-xl font-semibold"}," Step By Step Illustration ",-1)),e[33]||(e[33]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),t("form",{class:"space-y-4",ref_key:"form",ref:f},[t("div",fe,[t("div",ce,[e[29]||(e[29]=t("label",{class:"font-medium"},"Ascending / Descending:",-1)),J(t("select",{class:"field","onUpdate:modelValue":e[1]||(e[1]=a=>k.value=a)},e[28]||(e[28]=[t("option",{value:"ascending"},"Ascending",-1),t("option",{value:"descending"},"Descending",-1)]),512),[[Q,k.value]])]),t("button",{type:"button",class:"btn",disabled:g.length===8,onClick:p},"Add Row",8,ve)]),t("table",null,[e[30]||(e[30]=t("thead",null,[t("tr",null,[t("th",null,"Numbers to Sort"),t("th")])],-1)),t("tbody",null,[(s(!0),n(x,null,y(g,(a,b)=>(s(),n("tr",null,[t("td",null,[J(t("input",{type:"number","onUpdate:modelValue":T=>g[b]=T,min:"1",max:G},null,8,xe),[[Z,g[b]]])]),t("td",ye,[g.length>1?(s(),F(ee,{key:0,onClick:T=>u(b)},null,8,["onClick"])):q("",!0)])]))),256))])]),t("button",{type:"submit",class:"btn",onClick:Y(r,["prevent"])},"Run Algorithm")],512),e[34]||(e[34]=t("h2",{class:"mt-10 text-xl font-semibold"}," Results ",-1)),e[35]||(e[35]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),A.value?(s(),n("div",we,[h(pe,{log:z.log,"is-ascending":M.value,initial:g},null,8,["log","is-ascending","initial"])])):(s(),F(_,{key:1},{default:P(()=>[e[31]||(e[31]=t("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),t("button",{onClick:e[2]||(e[2]=Y(()=>r(),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[31]}))])]),_:2},1024))}};export{ze as default};
