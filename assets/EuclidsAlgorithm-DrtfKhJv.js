import{l as x,k as v,m as G,n as N,c as y,o as p,a as t,H as k,F as T,j as q,t as A,E as S,f as D,u as F,G as C,w as c,s as E,v as $,z as I,e as u,A as a}from"./index-CVscNJIu.js";import{_ as V,a as h,b as O}from"./EmptySpace-tFAoLFbP.js";import{_ as W}from"./Alert-CzlqMZmC.js";const B={class:"flex items-center justify-center w-full h-full max-w-xl mx-auto"},M={class:"max-w-md p-2 mx-auto mt-8 font-medium text-center border rounded-md bg-neutral-800 border-zinc-700"},j={__name:"EuclidsAlgorithm",props:{numberOne:Number,numberTwo:Number},setup(z){const l=z,o=x(()=>l.numberOne>=l.numberTwo?l.numberOne:l.numberTwo),n=x(()=>l.numberOne>=l.numberTwo?l.numberTwo:l.numberOne),r=x(()=>{let e=o.value,s=n.value,i=0,f=0;const w=[];for(;e>0&&s>0;)if(e>=s){const g=Math.floor(e/s);for(let d=0;d<g;d++)w.push({x:(i+d*s)/o.value*100+"%",y:f/n.value*100+"%",width:s/o.value*100+"%",height:s/n.value*100+"%",size:s});i+=g*s,e=e%s}else{const g=Math.floor(s/e);for(let d=0;d<g;d++)w.push({x:i/o.value*100+"%",y:(f+d*e)/n.value*100+"%",width:e/o.value*100+"%",height:e/n.value*100+"%",size:e});f+=g*e,s=s%e}return w}),m=v(0);let b=null;return G(()=>{b=setInterval(()=>{m.value<r.value.length?m.value++:m.value=0},1500)}),N(()=>{b&&clearInterval(b)}),(e,s)=>(p(),y(T,null,[t("div",B,[t("div",{class:"relative w-full h-full overflow-hidden border rounded-md border-zinc-600 bg-zinc-900",style:k([{"aspect-ratio":"var(--ratio)"},`--ratio: ${o.value} / ${n.value};`])},[(p(!0),y(T,null,q(r.value,(i,f)=>(p(),y("div",{key:f,class:"absolute flex items-center justify-center text-xs text-white transition-opacity duration-700 border border-zinc-600 bg-zinc-800 bg-[image:repeating-radial-gradient(var(--color-zinc-700)_0,var(--color-zinc-700)_1px,_transparent_1px,_transparent_100%)] bg-[size:20px_20px]",style:k({left:i.x,top:i.y,width:i.width,height:i.height,opacity:f<m.value?1:0})},A(i.size===1?`${i.size}`:`${i.size} Ã— ${i.size}`),5))),128))],4)]),t("div",M," GCD: "+A(r.value[r.value.length-1].size),1)],64))}},L={class:"mb-10 space-y-4"},R={class:"mb-10 space-y-4"},U={class:"flex gap-x-4"},H={class:"flex flex-col w-1/2 gap-2"},P={class:"flex flex-col w-1/2 gap-2"},Y={key:0},X={__name:"EuclidsAlgorithm",setup(z){const l=v(null),o=v(660),n=v(440),r=v(!1);S([o,n],()=>{r.value=!1});const m=()=>{if(!l.value.checkValidity())return l.value.reportValidity();r.value=!0};return(b,e)=>(p(),D(O,null,{[F(C).howItWorks.id]:c(()=>[t("div",L,[e[4]||(e[4]=t("p",null,[t("span",{class:"text-main"},"Euclid's Algorithm"),a(" is a method of finding the "),t("span",{class:"text-main"},"greatest common divisor (GCD)"),a(" of two numbers. The GCD of two numbers is the largest number that can divide both of them without leaving a remainder. ")],-1)),e[5]||(e[5]=t("h2",{class:"mt-10 text-xl font-semibold"}," Understanding the Greatest Common Divisor (GCD) ",-1)),e[6]||(e[6]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[7]||(e[7]=t("p",null," Lets say we have two numbers, 48 and 18. We will be looking for the greatest common divisor, which is the number that can divide both numbers without leaving any remainder. In this case, the GCD is 6, as its the largest factor of both numbers. ",-1)),e[8]||(e[8]=t("p",null,[a(" One way to do this is by "),t("span",{class:"text-main"},"prime factorization"),a(". We'll need to split our two numbers into their prime factors, and then multiply all the factors that both numbers have. Although this works for small numbers, doing this process for larger ones is extremely slow. ")],-1)),e[9]||(e[9]=t("p",null," We'll be looking at a more efficient solution to this problem: Euclid's Algorithm. ",-1)),e[10]||(e[10]=t("h2",{class:"mt-10 text-xl font-semibold"}," The Farmland Analogy ",-1)),e[11]||(e[11]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[12]||(e[12]=t("p",null," Imagine you have a rectangular piece of farmland. This farmland is 660m long and 420m wide, and you are tasked with dividing the farmland into square plots. ",-1)),u(h,{src:"/algorithms/number-theory/euclids-algorithm/empty-farmland.svg",class:"max-w-xl",caption:"A Piece of Farmland"}),e[13]||(e[13]=t("p",null," The only catch is, the square plots cannot simply be any size, they must be the largest possible size, i.e, all of the plots must be equal squares of the largest size. The question is, how can we figure out the largest size a square can be? ",-1)),u(h,{src:"/algorithms/number-theory/euclids-algorithm/finding-the-gcd.svg",class:"max-w-xl",caption:"Finding the Size of a Plot in the Farmland"}),e[14]||(e[14]=t("p",null," We can solve this using Euclid's Algorithm. To do this, we need to repeatedly take the larger side of the farmland and divide it by the smaller side, and seeing if we get a remainder. ",-1)),e[15]||(e[15]=t("p",null," If we get a remainder, then we need to repeat the process with the smaller side from earlier, and the newly calculated remainder. If there is no remainder, then we've successfully found our GCD! Lets go back to our farmland: ",-1)),u(h,{src:"/algorithms/number-theory/euclids-algorithm/division-1.svg",class:"max-w-xl",caption:"The First Division of Euclid's Algorithm"}),e[16]||(e[16]=t("p",null," First we'll take the smaller side of 420m and try to fit as many squares as we can inside the farmland. As illustrated above, we can only fit one, with a 240m by 420m strip of empty space left. ",-1)),e[17]||(e[17]=t("p",null," Since we have empty space, we'll have to redo the process for this empty space, now taking using a 240m square (the smaller side of the strip) to fill the space: ",-1)),u(h,{src:"/algorithms/number-theory/euclids-algorithm/division-2.svg",class:"max-w-xl",caption:"The Second Division of Euclid's Algorithm"}),e[18]||(e[18]=t("p",null," Again, we can only fit a single square of 240m in this empty space. This time, we are left with an empty strip of space of 240m by 180m. ",-1)),u(W,{"alert-style":"note"},{default:c(()=>e[3]||(e[3]=[t("div",{class:"space-y-4"},[t("p",null," Notice how after each step a huge portion of the empty space is filled up? That's what makes this algorithm so much more efficient than prime factorization! "),t("p",null,[a(" The "),t("span",{class:"text-main"},"time complexity"),a(" of this algorithm is "),t("span",{class:"text-main"},"O(log(min(a, b)))"),a(", making it much faster in finding the GCD of a pair of numbers than that of breaking each number down to its consectutive prime factors. ")])],-1)])),_:1,__:[3]}),e[19]||(e[19]=t("p",null," Lets repeat the process for the leftover empty space, using the smaller side of 180m: ",-1)),u(h,{src:"/algorithms/number-theory/euclids-algorithm/division-3.svg",class:"max-w-xl",caption:"The Third Division of Euclid's Algorithm"}),e[20]||(e[20]=t("p",null," Yet again, we could only fit a single square, leaving us with a 180m by 60m empty strip of space. We'll have to do this one more time, using the smaller side of 60m: ",-1)),u(h,{src:"/algorithms/number-theory/euclids-algorithm/division-4.svg",class:"max-w-md",caption:"The Final Division of Euclid's Algorithm"}),e[21]||(e[21]=t("p",null," This time we managed to fit 3 squares of 60m, leaving no empty space (i.e, our remainder is now zero), so GCD is 60, or in other words, the largest size squares we can divide the field up into are squares of 60m by 60m. ",-1)),e[22]||(e[22]=t("h2",{class:"mt-10 text-xl font-semibold"}," The Fibonacci Sequence ",-1)),e[23]||(e[23]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[24]||(e[24]=t("p",null,[a(" Notice any special pattern in our plot of farmland from earlier? If you look closely, it resembles the shape of the "),t("span",{class:"text-main"},"Fibonacci Spiral"),a(" very closely! Turns out that using Euclid's algorithm on two numbers from the Fibonacci sequence have the slowest performance times of all. ")],-1)),e[25]||(e[25]=t("p",null," If you try the same process using an adjacent pair of fibonacci numbers, you'll see that the resulting remainder is always the previous number in the series; certainly a cool pattern to know about! ",-1))])]),[F(C).visualizer.id]:c(()=>[t("div",R,[e[29]||(e[29]=t("h1",{class:"mb-4 text-xl font-semibold"}," Step By Step Illustration ",-1)),e[30]||(e[30]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),t("form",{class:"space-y-4",ref_key:"form",ref:l},[t("div",U,[t("div",H,[e[26]||(e[26]=t("label",{class:"font-medium"},"Number 1:",-1)),E(t("input",{type:"number",class:"!w-full field","onUpdate:modelValue":e[0]||(e[0]=s=>o.value=s)},null,512),[[$,o.value]])]),t("div",P,[e[27]||(e[27]=t("label",{class:"font-medium"},"Number 2:",-1)),E(t("input",{type:"number",class:"!w-full field","onUpdate:modelValue":e[1]||(e[1]=s=>n.value=s)},null,512),[[$,n.value]])])]),t("button",{type:"submit",class:"btn",onClick:I(m,["prevent"])},"Run Algorithm")],512),e[31]||(e[31]=t("h2",{class:"mt-10 text-xl font-semibold"}," Results ",-1)),e[32]||(e[32]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),r.value?(p(),y("div",Y,[u(j,{"number-one":o.value,"number-two":n.value},null,8,["number-one","number-two"])])):(p(),D(V,{key:1},{default:c(()=>[e[28]||(e[28]=t("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),t("button",{onClick:e[2]||(e[2]=I(()=>m(),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[28]}))])]),_:2},1024))}};export{X as default};
