import{r as u,a as R,w as N,b as g,u as C,t as S,d as k,e as t,h as v,f as b,v as T,C as O,i as F,F as L,g as V,k as m,l as s,o as r,j as M}from"./index-BVlDhJo8.js";import{_ as B,a as w,b as U,c as D}from"./TrashButton-Cgl2hxQH.js";import{_ as E,r as I}from"./SeekTimeGraph-DF1s9wQK.js";const K={class:"mb-10 space-y-4"},z={class:"mb-10 space-y-4"},H={class:"flex flex-wrap items-end gap-4"},P={class:"flex flex-col gap-2"},Q={class:"flex flex-col flex-1 gap-2"},W=["disabled"],j=["onUpdate:modelValue"],X={class:"w-20 mx-auto text-center"},G={key:0},x=199,A=0,ee={__name:"Look",setup(J){const h=u(null),l=R([98,183,37,122,14,124,65,67]),n=u(53),a=u("left"),d=R({orderedRequests:null,totalSeekTime:null}),f=u(!1);N([l,n,a],()=>{f.value=!1});const $=()=>{const i=Math.round(Math.random()*x);l.push(i)},c=i=>{l.splice(i,1)},y=()=>{if(!h.value.checkValidity())return h.value.reportValidity();const{orderedRequests:e,totalSeekTime:o}=I(n.value,l.slice(),"look",a.value);d.orderedRequests=e,d.totalSeekTime=o,f.value=!0};return(i,e)=>(r(),g(U,null,{[C(S).howItWorks.id]:k(()=>[t("div",K,[t("p",null,[e[5]||(e[5]=s(" The ")),e[6]||(e[6]=t("span",{class:"text-main"},"LOOK",-1)),e[7]||(e[7]=s(" algorithm is a variant of the ")),t("span",{class:"cursor-pointer text-main",onClick:e[0]||(e[0]=o=>i.$router.push("/disk-scheduling/scan"))},"SCAN"),e[8]||(e[8]=s(" algorithm, used to minimize the ")),e[9]||(e[9]=t("span",{class:"text-main"},"seek time",-1)),e[10]||(e[10]=s(" when responding to incoming disk requests. It works similarly to SCAN, however, it avoids traveling to the end of the disk, but rather to the last request. "))]),t("p",null,[e[11]||(e[11]=s(" This is a disk scheduling algorithm, which requires some basic knowledge about a hard disk. To learn more about disk architecture, see the ")),t("span",{class:"cursor-pointer text-main",onClick:e[1]||(e[1]=o=>i.$router.push("/disk-scheduling/first-come-first-serve"))},"First Come First Serve (FCFS)"),e[12]||(e[12]=s(" algorithm. "))]),e[13]||(e[13]=t("h2",{class:"mt-10 text-xl font-semibold"}," How the Algorithm Works ",-1)),e[14]||(e[14]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),e[15]||(e[15]=t("p",null," Similarly to the SCAN algorithm, LOOK travels towards the last request on the left or right, depending on the head direction, and then back towards the last request on the opposite side. The main difference is that LOOK avoids traveling to the ends of the disk if there are no requests, thus saving time. ",-1)),e[16]||(e[16]=t("p",null," To illustrate this, consider the following diagram, with disk requests plotted horizontally without any vertical order: ",-1)),m(w,{src:"/algorithms/disk-scheduling/look/direction-of-head.svg",class:"max-w-2xl"}),e[17]||(e[17]=t("p",null,[s(" The "),t("span",{class:"text-main"},"head direction"),s(" determines whether the LOOK algorithm first goes to the left most request, or towards the right most request. ")],-1)),e[18]||(e[18]=t("p",null," The following diagram shows how the algorithm would serve the pending disk requests if the direction of the head was towards the left. It also displays the final order of the requests served: ",-1)),m(w,{src:"/algorithms/disk-scheduling/look/look-left-to-right.svg",class:"max-w-3xl"}),e[19]||(e[19]=t("p",null,[s(" Once the order in which the requests are served is determined, a "),t("span",{class:"text-main"},"seek time graph"),s(" can be drawn to determine the total seek time. The following diagram shows the seek time graph for the algorithm with a left head direction: ")],-1)),m(w,{src:"/algorithms/disk-scheduling/look/look-seek-time-graph.svg"})])]),[C(S).visualizer.id]:k(()=>[t("div",z,[e[25]||(e[25]=t("h1",{class:"mb-4 text-xl font-semibold"}," Step By Step Illustration ",-1)),e[26]||(e[26]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),t("form",{class:"space-y-4",ref_key:"form",ref:h},[t("div",H,[t("div",P,[e[20]||(e[20]=t("label",{class:"font-medium"},"Current Head Position:",-1)),b(t("input",{type:"number",class:"field",min:A,max:x,"onUpdate:modelValue":e[2]||(e[2]=o=>n.value=o)},null,512),[[T,n.value]])]),t("div",Q,[e[22]||(e[22]=t("label",{class:"font-medium"},"Head Direction:",-1)),b(t("select",{class:"field","onUpdate:modelValue":e[3]||(e[3]=o=>a.value=o)},e[21]||(e[21]=[t("option",{value:"left"},"Left",-1),t("option",{value:"right"},"Right",-1)]),512),[[O,a.value]])]),t("button",{type:"button",class:"btn",disabled:l.length===15,onClick:$},"Add Row",8,W)]),t("table",null,[e[23]||(e[23]=t("thead",null,[t("tr",null,[t("th",null,"Disk Requests"),t("th")])],-1)),t("tbody",null,[(r(!0),v(L,null,F(l,(o,p)=>(r(),v("tr",null,[t("td",null,[b(t("input",{type:"number","onUpdate:modelValue":q=>l[p]=q,min:A,max:x},null,8,j),[[T,l[p]]])]),t("td",X,[l.length>1?(r(),g(D,{key:0,onClick:q=>c(p)},null,8,["onClick"])):M("",!0)])]))),256))])]),t("button",{type:"submit",class:"btn",onClick:V(y,["prevent"])},"Run Algorithm")],512),e[27]||(e[27]=t("h2",{class:"mt-10 text-xl font-semibold"}," Results ",-1)),e[28]||(e[28]=t("hr",{class:"mb-4 border-neutral-800"},null,-1)),f.value?(r(),v("div",G,[m(E,{"ordered-requests":d.orderedRequests,"total-seek-time":d.totalSeekTime},null,8,["ordered-requests","total-seek-time"])])):(r(),g(B,{key:1},{default:k(()=>[e[24]||(e[24]=t("p",{class:"mb-4"}," No results to display yet, try running the algorithm... ",-1)),t("button",{onClick:e[4]||(e[4]=V(()=>y(),["prevent"])),class:"btn"}," Run Algorithm ")]),_:1,__:[24]}))])]),_:2},1024))}};export{ee as default};
